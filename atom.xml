<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zzh的博客 | Alvin103</title>
  
  <subtitle>Hello world, heal the world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-14T10:31:32.968Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郑子豪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo同时部署github和gitee</title>
    <link href="http://yoursite.com/2020/03/10/hexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2github%E5%92%8Cgitee/"/>
    <id>http://yoursite.com/2020/03/10/hexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2github%E5%92%8Cgitee/</id>
    <published>2020-03-10T04:45:54.000Z</published>
    <updated>2020-03-14T10:31:32.968Z</updated>
    
    <content type="html"><![CDATA[<p>github访问速度也太慢了，体验很不好<br>部署到Gitee后访问太舒服了，毕竟服务器在国内<br>部署方法也很简单，跟之前差不多：<br>建仓库、添加SSH公钥、添加配置、开启Gitee Pages服务</p><a id="more"></a><p><img src="/2020/03/10/hexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2github%E5%92%8Cgitee/1.JPG" alt="1"><br><img src="/2020/03/10/hexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2github%E5%92%8Cgitee/2.JPG" alt="1"></p><p><img src="/2020/03/10/hexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2github%E5%92%8Cgitee/3.JPG" alt="1"><br><img src="/2020/03/10/hexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2github%E5%92%8Cgitee/4.JPG" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;github访问速度也太慢了，体验很不好&lt;br&gt;部署到Gitee后访问太舒服了，毕竟服务器在国内&lt;br&gt;部署方法也很简单，跟之前差不多：&lt;br&gt;建仓库、添加SSH公钥、添加配置、开启Gitee Pages服务&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>FlappyBird</title>
    <link href="http://yoursite.com/2020/03/05/FlappyBird/"/>
    <id>http://yoursite.com/2020/03/05/FlappyBird/</id>
    <published>2020-03-05T04:14:05.000Z</published>
    <updated>2020-03-14T10:03:46.467Z</updated>
    
    <content type="html"><![CDATA[<p>占坑~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;占坑~&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>操作系统整理</title>
    <link href="http://yoursite.com/2020/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-03-01T15:45:54.000Z</published>
    <updated>2020-03-14T10:29:53.592Z</updated>
    
    <content type="html"><![CDATA[<p>复习操作系统，学习总结，一点点整理。</p><a id="more"></a><hr><!-- TOC --><ul><li><a href="#操作系统operating-system概述">操作系统（Operating System）概述</a><ul><li><a href="#操作系统的功能和目标">操作系统的功能和目标</a></li><li><a href="#操作系统的特征">操作系统的特征</a></li><li><a href="#操作系统的发展与分类">操作系统的发展与分类</a></li><li><a href="#操作系统的运行机制和体系结构">操作系统的运行机制和体系结构</a></li><li><a href="#中断和异常">中断和异常</a></li><li><a href="#系统调用">系统调用</a></li></ul></li><li><a href="#进程管理">进程管理</a><ul><li><a href="#进程">进程</a></li><li><a href="#线程">线程</a></li><li><a href="#处理机调度">处理机调度</a></li><li><a href="#进程调度和调度算法">进程调度和调度算法</a></li><li><a href="#进程同步--互斥">进程同步 / 互斥</a></li><li><a href="#死锁">死锁</a></li></ul></li><li><a href="#内存管理">内存管理</a><ul><li><a href="#概念">概念</a></li><li><a href="#内存空间的分配与回收">内存空间的分配与回收</a></li><li><a href="#内存空间的扩充">内存空间的扩充</a></li><li><a href="#请求分页存储管理">请求分页存储管理</a></li><li><a href="#页面分配策略">页面分配策略</a></li></ul></li><li><a href="#文件管理">文件管理</a><ul><li><a href="#文件的逻辑结构">文件的逻辑结构</a></li><li><a href="#文件目录">文件目录</a></li><li><a href="#文件的物理结构">文件的物理结构</a></li><li><a href="#文件存储空间管理">文件存储空间管理</a></li><li><a href="#文件基本操作">文件基本操作</a></li><li><a href="#磁盘">磁盘</a></li></ul></li><li><a href="#设备管理">设备管理</a><ul><li><a href="#io设备">I/O设备</a></li><li><a href="#io控制方式">I/O控制方式</a></li><li><a href="#io软件层次">I/O软件层次</a></li><li><a href="#假脱机技术">假脱机技术</a></li></ul></li></ul><!-- /TOC --><hr><h2 id="操作系统（Operating-System）概述"><a href="#操作系统（Operating-System）概述" class="headerlink" title="操作系统（Operating System）概述"></a>操作系统（Operating System）概述</h2><p>控制和管理计算机的硬件和软件，并合理调度计算机工作和资源分配，提供给用户和其他软件接口和环境，是计算机系统中最基本的系统软件</p><h3 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h3><table><thead><tr><th>Operating System</th><th>功能</th><th>目标</th></tr></thead><tbody><tr><td>系统资源的管理者</td><td>文件管理<br> 存储器管理（内存）<br>处理机管理（CPU） <br>设备管理</td><td>安全、高效</td></tr><tr><td>用户和硬件之间的接口</td><td>命令接口（联机 脱机）<br> 程序接口 （系统调用）<br>GUI -图形用户界面</td><td>方便用户使用</td></tr><tr><td>最接近硬件的层次</td><td><center> 对硬件机器的扩展</center></td><td></td></tr></tbody></table><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><table><thead><tr><th align="center">特征</th><th>&emsp;</th></tr></thead><tbody><tr><td align="center">并发</td><td>并发：两个或多个事件同一时间间隔发生<br>并行：两个或多个事件同时发生</td></tr><tr><td align="center">共享</td><td>资源共享，系统中的资源可供内存中多个并发的进程共同使用 <br>1.互斥共享  2.同时共享</td></tr><tr><td align="center">虚拟</td><td>物理实体-&gt;逻辑对应物  <br> 空分复用技术（虚拟存储器） <br>时分复用技术（虚拟处理器）</td></tr><tr><td align="center">异步</td><td>走走停停~</td></tr></tbody></table><h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><p>手工-&gt;单道批处理-&gt;多道批处理-&gt;分时操作系统-&gt;实时操作系统（硬/软）<br>个人操作系统 网络操作系统 分布式操作系统</p><h3 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h3><table><thead><tr><th>&emsp;</th><th>&emsp;</th></tr></thead><tbody><tr><td>运行机制</td><td>特权指令 非特权指令<br>核心态&emsp;&ensp;用户态<br>内核程序 应用程序</td></tr><tr><td>内核</td><td>操作系统最基本、核心的部分<br>时钟管理  中断处理  原语<br>对系统资源进行管理<br>不同操作系统对内核功能划分不同</td></tr><tr><td>体系结构</td><td>大内核 高性能 内核代码庞大难维护<br>微内核 低性能 内核功能少方维护</td></tr></tbody></table><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><table><thead><tr><th>中断和异常</th></tr></thead><tbody><tr><td>为实现多道程序并发执行</td></tr><tr><td>发生中断-&gt;立即进入核心态 操作系统介入管理</td></tr><tr><td>内中断 （异常、陷入、例外） （trap、fault、abort</td></tr><tr><td>外中断  与指令无关 I/O完成中断 人工干预</td></tr></tbody></table><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><table><thead><tr><th>系统调用</th></tr></thead><tbody><tr><td>应用程序通过系统调用请求操作系统的服务，保证系统稳定性和安全性。</td></tr><tr><td>设备管理 文件管理 进程控制 进程通信 内存管理</td></tr><tr><td>传递系统调用参数-&gt;执行陷入指令（用户态）-&gt;<br>切换到核心态执行系统调用相应服务程序-&gt;返回用户程序</td></tr><tr><td>系统调用与库函数区别</td></tr></tbody></table><hr><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><table><thead><tr><th>进程</th><th>&emsp;</th></tr></thead><tbody><tr><td>定义</td><td>进程实体的运行过程，资源分配的基本单位。</td></tr><tr><td>组成</td><td>程序段、数据段、进程控制块（PCB）组成了进程实体（映像）</td></tr><tr><td>组织</td><td>链接方式 索引方式</td></tr><tr><td>特征</td><td>动态性 并发性 独立性 异步性 结构性</td></tr></tbody></table><table><thead><tr><th>五种状态</th><th>&emsp;</th></tr></thead><tbody><tr><td>运行态（Running）</td><td>占有CPU，并在CPU上运行</td></tr><tr><td>就绪态（Ready）</td><td>具备运行条件，由于没有空闲CPU，暂时不能运行</td></tr><tr><td>阻塞态（Waiting/Blocked）</td><td>等待某一事件而暂时不能运行</td></tr><tr><td>创建态（New）</td><td>分配资源，初始化PCB</td></tr><tr><td>终止态（Terminated）</td><td>回收资源，撤销PCB</td></tr></tbody></table><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/EpnZ2Lm61bRtWOHnS20OT78H7fNEzgBsJa25.BkeATr*yDNEiu0NgLB6nRBZxrTSnFjN.CfB5JnLM9HNfILMoQ!!/b&bo=KAOGAQAAAAARB5w!&rf=viewer_4"><p>进程控制：实现进程状态转换<br>原语，采用“关中断指令”和“开中断指令”实现  </p><p>1.更新PCB中的信息（进程状态标志，运行环境保存/恢复）<br>&emsp;a.一定会修改状态标志<br>&emsp;b.剥夺当前进程CPU使用权必然需要保存运行环境<br>&emsp;c.进程开始运行前必然要恢复其运行环境<br>2.将PCB插入合适队列<br>3.分配/回收资源  </p><table><thead><tr><th>进程通信方式</th><th>&emsp;</th></tr></thead><tbody><tr><td>共享存储</td><td>设置共享空间，互斥访问</td></tr><tr><td>消息传递</td><td>直接 / 间接（消息先发到中间体-信箱）</td></tr><tr><td>管道通信</td><td>单管道半双工，写满了读，读空了写</td></tr></tbody></table><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是独立调度的基本单位，一个进程中可以有多个线程，它们共享进程资源；各线程间也能并发，提升了并发度；引入线程后，并发所带来的系统开销小，因为同一进程内不需要切换进程环境。</p><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/Af1yGqSdppVqA7I0*cpgDDm89hYegaiFMENKJ*RbNBmjHL4k94lQFRwErsP87mo.BFfbUu4m*3EZJLPldRPGgfodH*HkVlObZVg6GiK6Aco!/b&bo=fQKfAQAAAAARF8E!&rf=viewer_4"><p>线程的实现方式：用户级线程 内核级线程 组合方式</p><table><thead><tr><th>多线程模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>多对一</td><td>进程管理开销小效率高</td><td>一阻全阻，并发性低</td></tr><tr><td>一对一</td><td>多核并行，并发度高</td><td>进程管理开销大</td></tr><tr><td>多对多</td><td>集前两者之所长</td><td></td></tr></tbody></table><hr><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><table><thead><tr><th>三层调度</th><th>内容</th><th>发生在</th><th>频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度（作业调度）</td><td>按规则从后备队列选择作业调入内存创建进程</td><td>外存-&gt;内存<br>（面向作业）</td><td>低</td><td>无-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度（内存调度）</td><td>按规则从挂起队列选择进程调回内存</td><td>外存-&gt;内存<br>（面向进程）</td><td>中</td><td>就绪挂起-&gt;就绪态 阻塞挂起-&gt;阻塞态</td></tr><tr><td>低级调度（进程调度）</td><td>按规则从就绪队列选择进程为其分配处理机</td><td>内存-&gt;CPU</td><td>高</td><td>就绪态-&gt;运行态</td></tr></tbody></table><p>挂起态：就绪挂起 阻塞挂起</p><h3 id="进程调度和调度算法"><a href="#进程调度和调度算法" class="headerlink" title="进程调度和调度算法"></a>进程调度和调度算法</h3><p>需要进行进程调度的情况：<br>&emsp;主动放弃处理机（进程正常/异常终止、主动请求阻塞如等待I/O）<br>&emsp;被动放弃处理机（时间片用完、更紧急的事如I/O中断、更高优先级的进程进入就绪队列）<br>不能进行进程调度的情况：<br>&emsp;1.处理中断的过程中&emsp;2.进程在操作系统内核程序临界区中&emsp;3.在原子操作过程中（原语）</p><p>进程调度方式：剥夺/非剥夺  </p><p>进程调度、切换有代价，并不是调度越频繁并发度越高。</p><p>调度算法评价指标：CPU利用率 系统吞吐量 周转时间（平均、带权、平均带权） 等待时间（进程、作业、平均） 响应时间</p><table><thead><tr><th>早起批处理系统 调度算法</th><th>抢占</th><th>特点</th><th>饥饿</th></tr></thead><tbody><tr><td>先来先服务算法<br>(FCFS, First Come First Serve0)</td><td>非抢占</td><td>公平简单，短作业不利，考虑等待时间</td><td>不会</td></tr><tr><td>短作业优先算法<br>（SJF, Shortest Job First）</td><td>抢占SRNT / 非抢占</td><td>长作业不利，考虑运行时间</td><td>会</td></tr><tr><td>高响应比优先算法<br>（HRRN, Highest Response Ratio Next）</td><td>非抢占</td><td>上述两种算法权衡折中<br>响应比 = （等待 + 要求服务）/ 要求服务</td><td>不会</td></tr></tbody></table><table><thead><tr><th>交互式系统 调度算法</th><th>抢占</th><th>特点</th><th>饥饿</th></tr></thead><tbody><tr><td>时间片轮转算法（RR, Round-Robin）</td><td>抢占</td><td>适于分时操作系统，注重响应时间，不考虑紧急</td><td>不会</td></tr><tr><td>优先级调度算法</td><td>抢占/非抢占</td><td>适于实时操作系统，区分调整重要程度</td><td>会</td></tr><tr><td>多级反馈队列调度算法</td><td>抢占</td><td>平衡公平</td><td>会</td></tr></tbody></table><hr><h3 id="进程同步-互斥"><a href="#进程同步-互斥" class="headerlink" title="进程同步 / 互斥"></a>进程同步 / 互斥</h3><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。<br>互斥：多个进程在同一时刻只有一个进程能进入临界区。&emsp;进入区、临界区、退出去、剩余区。<br>互斥原则：1.空闲让进&emsp;2.忙则等待&emsp;3.有限等待&emsp;4.让权等待</p><table><thead><tr><th>进程互斥的软件实现方法</th><th>思想</th><th>主要问题</th></tr></thead><tbody><tr><td>单标志法</td><td>每个进程进入临界区的权限只能被另一个进程赋予</td><td>违背 空闲让进 原则</td></tr><tr><td>双标志先检查法</td><td>flag[]数组标记各进程想进入临界区的意愿<br>先“检查”后“上锁”</td><td>违背 忙则等待 原则</td></tr><tr><td>双标志后检查法</td><td>先“上锁” 后“检查”</td><td>违背了 空闲让进 和 有限等待 原则<br>产生饥饿</td></tr><tr><td>Peterson算法</td><td>谦让，主动让对方先使用临界区</td><td>未遵循 让权等待 原则，发生忙等</td></tr></tbody></table><table><thead><tr><th>进程互斥的硬件实现方法</th><th>思想</th><th>主要问题</th></tr></thead><tbody><tr><td>中断屏蔽方法</td><td>开/关中断指令</td><td>不适用多处理机，只适用OS内核进程，不适用于用户进程</td></tr><tr><td>TestAndSet指令</td><td>硬件实现，执行过程不允被许中断</td><td>不满足 让权等待 原则，发生忙等</td></tr><tr><td>Swap指令</td><td>同上</td><td>同上</td></tr></tbody></table><p>信号量机制</p><p>1.双标志检查法中，“检查”和“上锁”无法一气呵成，导致了两个进程可能同时进入临界区。<br>2.所有解决方案无法实现 让权等待</p><p>Dijkstra 提出实现进程同步、互斥的方法——信号量机制，通过操作系统提供的一对原语对信号量进行操作。<br>信号量：表示系统中某种资源的数量。整型信号量&emsp;记录型信号量<br>一对原语：wait(S) 和 signal(s)&emsp;简称为P、V操作，遗漏P则不能保证互斥访问，遗漏V则不能在使用临界资源之后将其释放（给其他等待的进程）<br>实现进程互斥：临界区前P，临界区后V&emsp;实现进程同步：“前操作”后V，“后操作”前P  </p><p>优点：简单且表达能力强，用P.V操作可解决任何同步互斥问题<br>缺点：不够安全；P.V操作使用不当会出现死锁  </p><table><thead><tr><th>进程互斥同步问题</th><th>同步、互斥关系</th><th>P、V顺序</th></tr></thead><tbody><tr><td>生产者消费者问题</td><td>1.缓冲区没满生产者才能放产品<br>2.缓冲区不空消费者才能取产品<br>缓冲区是临界资源，需互斥访问</td><td>生产者消耗(P )一个缓冲区，并生产(V)一个产品<br>消费者消耗(P)一个产品，并释放(V)一个空闲缓冲区<br>临界区前P、临界区后V 实现互斥访问</td></tr><tr><td>多生产者多消费者问题</td><td>1.缓冲区为空才能放<br>2.生产者1放入产品1后，消费者1才能取产品2<br>3.生产者2放入产品2后，消费者2才能取产品2<br>缓冲区是临界资源，需互斥访问</td><td>生产者1/2消耗(P)一个缓冲区，生产(V)一个产品1/2<br>消费者1/2消耗(P)产品1/2，释放(V)一个空闲缓冲区<br>临界区前P、临界区后V 实现互斥访问</td></tr><tr><td>吸烟者问题</td><td>1.桌上有组合一，抽烟者1取走<br>2.桌上有组合二，抽烟者2取走<br>3.桌上有组合三，抽烟者3取走<br>4.发出完成信号，供应者将下一组合放桌上<br>缓冲区是临界资源，需互斥访问</td><td>供应者放入某组合后(V),然后(P)等待信号<br>吸烟者拿组合前(P),抽完烟(V)<br>临界区前P、临界区后V 实现互斥访问</td></tr><tr><td>读者写者问题</td><td>1.写完才能读<br>2.读者和其他写者退出后才能写<br>3.允许多个读者同时读<br>缓冲区是临界资源，需互斥访问</td><td>写之前加锁(P)写完解锁(V)<br>第一个读进程加锁(P)最后一个读进程解锁(V)<br>为解决饥饿，再在写者和第一个读者设置互斥信号量<br>各个读进程加P、V互斥访问</td></tr><tr><td>哲学家进餐问题</td><td>1.哲学家与左右邻居对中间筷子互斥访问<br>2.每个哲学家需同时持有两个临界资源<br>如何避免死锁</td><td>1.限制同时进餐的哲学家人数<br>2.要求奇/偶数号先拿左/右的筷子<br>3.仅当一个哲学家左右筷子都可使用才能拿起筷子</td></tr></tbody></table><p>信号量机制存在的问题：编写程序困难、易出错。<br>1973年，Brinch Hansen首次在Pascal中引入管程——高级同步机制，目的是更方便的实现进程互斥和同步</p><p>管程 是一种特殊软件模块：<br>1.局部与管程的共享数据结构说明<br>2.对该数据结构进行操作的一组过程<br>3.对局部与管程的共享数据设置初值的语句<br>4.管程有一个名字<br>特征：<br>1.局部与管程的数据只能被局部与管程的过程所访问<br>2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据<br>3.每次仅允许一个进程在管程内执行某个内部过程</p><hr><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁：各进程 ( &gt;=2 ) 互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。<br>饥饿：由于长期得不到资源，某进程无法向前推进的现象。</p><p>产生死锁条件（缺一不可）<br>&emsp;互斥条件：只有对互斥使用的资源争抢才会导致死锁。<br>&emsp;不剥夺条件：进程所获得资源未使用完之前，不能由其他进程夺走，只能主动释放。<br>&emsp;请求和保持条件：进程已有一资源，请求另一资源，阻塞，又对自己的资源保持不放。<br>&emsp;循环等待条件：存在一种进程资源的循环等待链。  </p><p>发生死锁：1.对系统资源的竞争&emsp;2.进程推进顺序非法&emsp;3.信号量使用不当</p><p>预防死锁（破坏条件）<br>避免死锁（算法防止系统进入不安全状态，<a href="银行家算法.md">银行家算法</a>）<br>死锁的检测和解除（资源分配图，资源剥夺法、撤销进程法、进程回退法）  </p><hr><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>逻辑地址（相对地址）&emsp;物理地址（绝对地址）</p><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/Af1yGqSdppVqA7I0*cpgDA*PS4bwwejYvSzj0kS67N2b871zDePSNa9CP6yuUY.5PgaHABVLUw9rn6q1Nlrv3psmXsIrm7OCjW1gBoCBSEk!/b&bo=agMwAQAAAAADF2o!&rf=viewer_4" height="250"><p>链接方式： 静态链接&emsp;装入时动态链接&emsp;运行时动态链接<br>装入方式： 绝对装入&emsp;可重定位装入&emsp;动态运行时装入  </p><p>内存管理概念：</p><ol><li>内存空间的分配与回收</li><li>内存空间的扩充（虚拟性）</li><li>地址转换（三种）</li><li>存储保护（上下限寄存器、重定位+界地址寄存器）</li></ol><hr><h3 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h3><table><thead><tr><th>连续分配管理方式</th><th>内容</th><th>特点</th></tr></thead><tbody><tr><td>单一连续分配</td><td>内存被分为系统区和用户区。</td><td>简单；无外部碎片，有内部碎片；<br>采用覆盖技术扩充内存；不一定需要内存保护（eg:MS-DOS）<br>只能用于单用户、单任务的OS；；存储器利用率低。</td></tr><tr><td>固定分区分配</td><td>将整个用户空间分为若干个分区，每个分区只装入一道作业</td><td>简单；无外部碎片，有内部碎片；<br>分区相等适于一控多，分区不等更灵活<br>用户程序太大，分区不能满足，只能用覆盖技术（降低性能）<br>内存利用率低</td></tr><tr><td>动态分区分配</td><td>进程装入内存时，根据大小动态建立分区<br>空闲分区表/空闲分区链记录内存使用情况<br>动态分区分配算法进行分配 回收<br></td><td>无内部碎片，有外部碎片；可通过紧凑技术解决外部碎片；<br>支持多道程序</td></tr></tbody></table><p>内部碎片：分配给进程的内存中没用上<br>外部碎片：内存中由于太小难以利用的分区</p><table><thead><tr><th>动态分区分配算法</th><th>算法思想</th><th>实现方法</th></tr></thead><tbody><tr><td>首次适应算法</td><td>从低地址开始找到第一个能满足大小的分区</td><td>空闲分区按地址递增的次序排列</td></tr><tr><td>最佳适应算法</td><td>优先使用更小的空闲区</td><td>空闲分区按容量递增的次序链接</td></tr><tr><td>最坏适应算法</td><td>优先使用最大的空闲区</td><td>空闲分区按容量递减的次序链接</td></tr><tr><td>邻近适应算法</td><td>从上次查找结束的位置开始检索</td><td>空闲分区按地址递增的次序排列（可排成循环链表）</td></tr></tbody></table><table><thead><tr><th>非连续分配管理方式</th><th>思想</th><th>实现地址转换</th></tr></thead><tbody><tr><td>基本分页存储管理</td><td>把进程分页，各页面离散地放到各内存块中</td><td>计算逻辑地址对应页号<br>找到对应页面在内存中位置<br>计算逻辑地址对应页内偏移量<br>物理地址 = 页面地址 + 页面偏移量</td></tr><tr><td>基本分段存储管理</td><td>按程序自身逻辑划分为若干段</td><td>根据逻辑地址得到段号和段内地址<br>判断是否越界，越界中断<br>查询段表，找到段表项<br>检查段内地址是否超过断长，超过中断<br>计算物理地址 E = 段基址b + 段内地址W(偏移量)</td></tr><tr><td>段页式管理方式</td><td>分页：内存利用率高，无外部碎片，少量内部碎片<br>分页：便于实现信息共享和保护，会产生外部碎片<br>将进程按逻辑模块分段，再将各段分页<br>集合了两者优点</td><td>根据逻辑地址得到段号、页号、页内偏移量<br>判断段号是否越界，越界中断<br>查询段表，找到对应段表项<br>检查页号是否越界，越界中断<br>根据页表存放块号、页号查询页表，找到对应页表项<br>根据内存块号、业内偏移量得到物理地址</td></tr></tbody></table><p>页 是信息的物理单位 对用户不可见 进程地址空间是一维的  由于页面不是按逻辑模块划分，难以实现共享和保护<br>段 是信息的逻辑单位 对用户可见&emsp; 进程地址空间是二维的 分段更容易实现信息的共享和保护</p><hr><h3 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h3><p>解决程序大小超过物理内存总和的问题</p><table><thead><tr><th>内存扩充技术</th><th>思想、特征</th></tr></thead><tbody><tr><td>覆盖技术</td><td>将程序分为多个段，常用的段常驻内存，不常用的只在需要时调入。  <br>缺点：对用户不透明，增加了编程负担，已退出历史舞台~</td></tr><tr><td>交换技术</td><td>内存紧张时，将某些进程暂时换出内存，把外存中满足运行条件的进程换入。  <br>将磁盘分为文件区（离散分配）和对换区（连续分配）</td></tr><tr><td>虚拟存储技术</td><td>虚拟内存的实现建立在离散分配的内存管理方式之上<br>程序不需全部装入即可运行、运行时根据需要动态调入数据<br>传统存储管理方式特征、缺点：一次性 驻留性<br>虚拟内存特征：多次性、对换性、虚拟性</td></tr></tbody></table><p>虚拟内存实现：请求分页存储管理 请求分段存储管理 请求段页式存储管理</p><hr><h3 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h3><p>请求分页管理 与 基本分页管理的 主要区别：<br>访问信息不在内存时，由操作系统将所需信息从外存调入内存（请求调页）<br>内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存（页面置换）</p><p>页表机制：增加了几个表项<br><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/Af1yGqSdppVqA7I0*cpgDJyCFumPy.vbKeR1Neq1mfJTCOzkBofe9h91P7ObGY9KiOisrGab.uLU1ePsYYvd7xhvbudWqNOe9tOnV6NFPuk!/b&bo=QAL0AAAAAAADF4Q!&rf=viewer_4"></p><p>缺页中断机构：找到页表项检查是否在内存，若不在，产生缺页中断（内中断）<br>地址变换机构：找到页表项检查是否在内存，若不在，请求调页，若内存不足，还需换出页面并修改相应表项  </p><p>页面置换算法：</p><ol><li>最佳置换算法（OPT，Optimal）：淘汰最长时间不在被访问的页面 实际无法实现  </li><li>先进先出算法（FIFO）：淘汰最早进入内存的页面 Belady异常 算法性能差</li><li>最近最久未使用置换算法（LRU）：淘汰最近最久未使用的页面 性能好 实现困难开销大</li><li>时钟置换算法（CLOCK）/最近未用算法（NRU，Not Recently Used）：为页面设置访问位 最多经过两轮扫描 性能和开销均衡</li><li>改进型的时钟置换算法：只有被淘汰的页面被修改时，才需要写回外存 增加修改位 最多经过四轮扫描</li></ol><hr><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p>驻留集：请求分页存储管理中给进程分配的物理块的几何。在虚拟存储技术的系统中，驻留集大小一般小于进程总大小。<br>驻留集太小-&gt;缺页频繁，花大量时间处理缺页，用于进程时间少<br>驻留集太大-&gt;并发度下降，资源利用率低。</p><p>固定分配 / 可变分配&emsp;&emsp;&emsp;局部置换 / 全局置换  </p><table><thead><tr><th>页面分配策略</th><th>内容</th><th>特点</th></tr></thead><tbody><tr><td>固定分配局部置换</td><td>系统为进程分配一定数量物理块，整个运行期间不改变<br>发生缺页时只能从该进程在内存中的页面中选出一页换出</td><td>很难在刚开始就确定分配多少物理跨合理</td></tr><tr><td>可变分配全局置换</td><td>刚开始会为进程分配一定数量物理块,操作系统会保持一个空闲物理块队列。<br>发生缺页时，从空闲物理块中取出一块分配给进程<br>若无空闲物理块，可选择为锁定的页面换出外存，再将物理块分配给缺页进程。</td><td>只要发生缺页都将获得新的物理块<br>调出的页面可能是系统中任何进程的页，该进程缺页率会增加</td></tr><tr><td>可变分配局部置换</td><td>刚开始会为进程分配一定数量物理块<br>发生缺页时只允许从自己的物理块中换出</td><td>频繁缺页，系统会为该进程分配物理块，反之减少</td></tr></tbody></table><p>何时调入页面：</p><ol><li>预调页策略：主要用于进程的首次调入，由程序员指出先调入那些部分</li><li>请求调页策略：运行期间发现缺页时才将所缺页面调入内存</li></ol><p>抖动（颠簸）现象：频繁的页面调度，产生原因是频繁访问的页面数多于可用物理块（分配给进程的物理块不够）<br>工作集：某段时间间隔里，进程实际访问页面的集合</p><hr><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p>无结构文件：文件内部的数据就是一系列二进制流或字符流组成 如.txt文件<br>有结构文件：由一组相似的记录组成，又称“记录式文件”，如数据库表文件，一般每条纪律有一个关键字。根据记录长度又可分为定长 / 可变长记录  </p><p>有结构文件的逻辑结构：</p><ol><li>顺序文件：文件中的记录顺序排列（逻辑上），记录可以是定长或可变长，各个记录在物理上可以顺序存储（可变长记录无法实现随机存取）或链式存储（无法实现随机存取）<br>串结构（记录顺序与关键字无关） 顺序结构（记录顺序按关键字排列）</li><li>索引文件：建立索引表（定长记录的顺序文件），每条记录对应索引项，文件中的记录在物理上可以离散存放。<br>主要用于对信息处理及时性要求高的场合</li><li>索引顺序文件：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项，减少了索引表项。<br>为进一步提高检索效率，可以建立多级索引表</li></ol><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>文件控制块（FCB，File Control Block）：基本信息、存取控制信息、使用信息</p><p>单级目录结构 两级目录结构 树形目录结构 无环图目录结构</p><p>索引结点（FCB的改进）：除文件名之外的文件描述信息都放到索引结点，提升了文件检索速度</p><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><table><thead><tr><th>文件分配方式</th><th>内容</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>连续分配</td><td>每个文件在磁盘上占有一组连续的块</td><td>支持顺序访问和随机访问，顺序访问时速度最快</td><td>文件拓展不方便，存储空间利用率低，产生磁盘碎片</td></tr><tr><td>链接分配</td><td>为文件分配离散的磁盘块<br>隐式 / 显式链接</td><td>隐式：便于拓展，无碎片，外存利用率高<br>显式：便于拓展，无碎片，外存利用率高，且支持随机访问，文件访问率更高</td><td>隐式：只支持顺序访问，查找效率低，指向下一块的指针也会耗费存储空间<br>显式：文件分配表需占用存储空间</td></tr><tr><td>索引分配</td><td>文件离散分配在各个磁盘块中<br>系统为每个文件建立索引表<br>若文件太大，可采用链接方案、多层索引、混合索引</td><td>支持随机访问，易于扩展</td><td>索引表需占用一定空间，访问数据块前需先读入索引块</td></tr></tbody></table><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><table><thead><tr><th>存储空间管理</th><th>分配</th><th>回收</th><th>特点</th></tr></thead><tbody><tr><td>空闲表法</td><td>与动态分区分配类似，为文件分配连续存储空间<br>同样可采用首次适应、最佳适应、最坏适应算法决定为文件分配区间</td><td>与动态分区分配类似，注意表项合并问题</td><td>适用于“连续分配方式”</td></tr><tr><td>空闲链表法（盘块链）</td><td>从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针</td><td>回收的盘块依次挂到链尾，并修改空闲链的链尾指针</td><td>操作系统保存着链头、链尾指针<br>适用于离散分配，为文件分配多个盘块时要重复多次操作</td></tr><tr><td>空闲链表法（盘区链）</td><td>可采用首次适应、最佳适应的算法从链头开始检索<br>注意分配后修改相应链指针、盘区大小等数据</td><td>若回收区和某个空闲盘区相邻，需将会收取合并到空闲盘区中<br>若回收区没有和任何空闲区相邻，将回收区最为单独空闲盘区挂到链尾</td><td>操作系统保存着链头、链尾指针<br>离散分配、连续分配都适用，为文件分配多个盘块时效率更高</td></tr><tr><td>位视图法</td><td>顺序扫描位示图，找到K个相邻或不相邻的“0”<br>根据字号、位号算出对应盘块号，将相应盘块分给文件<br>将相应位设置为“1”</td><td>根据回收的盘块号计算出对应的字号、位号<br>将相应二进制位设置为“0”</td><td>连续分配、离散分配都适用</td></tr><tr><td>成组链接法</td><td></td><td></td><td>UNIX采用的策略，适合大型文件系统</td></tr></tbody></table><h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><p>创建(create)：1.在外存中找到文件所需空间 2.根据文件存放路径找到目录，创建目录项  </p><p>删除(delete)：1.根据文件存放路径和文件名找到目录项 2.回收文件占用的磁盘块 3.删除文件对应目录项  </p><p>打开(open)：1.根据文件存放路径和文件名找到目录项，并检查是否有权限 2.将目录项复制到内存中的“打开文件表”</p><p>关闭(close)：1.进程打开文件表相应表项删除 2.回收内存空间等资源 3.系统打开文件表的打开计数器count-1 若count为0删除对应表项</p><p>读(read)：根据读指针、读入数据量、内存位置 将文件数据从外存读入内存</p><p>写(write)：根据写指针、写出数据量、内存位置 将文件数据从内存写出外存  </p><p>文件共享</p><p>基于索引结点的共享方式（硬链接）：<br>&emsp;索引结点中设置一个链接计数变量count，表示链接到本索引结点上的用户目录项数<br>基于符号链的共享方式（软链接）：<br>&emsp;类似Windows的“快捷方式”，创建Link型文件，访问速度比硬链接慢  </p><p>文件保护  </p><p>口令保护 加密保护 访问控制</p><p>文件系统的层次结构：<br>例：请求删除文件”D:/工作目录/学生信息.xlsx”的最后100条记录  </p><ol><li>用户通过操作系统接口发出请求——用户接口</li><li>查找目录找到目录项——文件目录系统</li><li>检查是否有访问权限——存取控制模块</li><li>将记录号转为逻辑地址——逻辑文件系统与文件信息缓存区</li><li>转换为实际的物理地址——物理文件系统</li><li>对磁盘设备发出请求——设备管理程序模块</li><li>回收空闲盘块——辅助分配模块11</li></ol><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/Af1yGqSdppVqA7I0*cpgDOCrgsc4Qr*fVJynTLpLNoJyr7*UiGI4yGSah.zIiIuB6fqnVFDC4TO3NKaeQEMA9RqsddCOuFl*hvH.lG0k82k!/b&bo=ZQGhAQAAAAADF*Y!&rf=viewer_4"><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘调度算法：<br>先来先服务（FCFS）最短寻找时间优先（SSTF）扫描算法（电梯算法、SCAN）循环扫描算法（C-SCAN）LOOK C-LOOK<br>减少延长时间的方法：交替编号 错位命名</p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><p>按特性分类：人机交互类外部设备 存储设备 网络通信设备<br>按传输速率分类：低中高速度<br>按信息交换的单位分类：块设备（传输快、可寻址） 字符设备（传输慢、不可寻址，常用中断驱动方式）</p><p>I/O控制器：I/O设备的电子部件，用于实现对I/O设备的控制<br>功能：</p><ol><li>接收和识别CPU发出的命令（控制寄存器）</li><li>向CPU报告设备状态（状态寄存器）</li><li>数据交换（数据寄存器）</li><li>地址识别（由I/O逻辑实现）<br>组成：</li><li>CPU与控制器之间的接口</li><li>I/O逻辑</li><li>控制器与设备之间的接口</li></ol><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/EpnZ2Lm61bRtWOHnS20OT4CjjEz0Oy92ggfqqZ*R9qjYZBEdpC3*h*QHreOMPP6chCo.covODddeCo0YKlCaDg!!/b&bo=7gJtAQAAAAADB6I!&rf=viewer_4"><h3 id="I-O软件层次"><a href="#I-O软件层次" class="headerlink" title="I/O软件层次"></a>I/O软件层次</h3><table><thead><tr><th>层次</th><th>功能</th></tr></thead><tbody><tr><td>用户层软件</td><td>与用户交互的接口，用户使用库函数操作设备，通过系统调用请求内核服务</td></tr><tr><td>设备独立性软件</td><td>1.向上层提供接口 2.实现对设备的保护 3.差错处理 4.设备分配与回收 5.数据缓冲区管理 6.建立逻辑设备名到物理设备名的映射关系<br>逻辑设备表（LUT）</td></tr><tr><td>设备驱动程序</td><td>负责对硬件设备的具体控制，设置设备寄存器，检查设备状态等</td></tr><tr><td>中断处理程序</td><td>进行中断处理</td></tr><tr><td>硬件</td><td>执行I/O操作</td></tr></tbody></table><h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p>…待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习操作系统，学习总结，一点点整理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>银行家算法</title>
    <link href="http://yoursite.com/2020/02/28/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/28/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-28T12:45:54.000Z</published>
    <updated>2020-03-14T08:23:53.242Z</updated>
    
    <content type="html"><![CDATA[<p>银行家算法是一种最有代表性的避免死锁的算法。</p><!-- TOC --><ul><li><a href="#死锁">死锁</a></li><li><a href="#银行家算法">银行家算法</a><ul><li><a href="#背景">背景</a></li><li><a href="#数据结构">数据结构</a></li><li><a href="#步骤">步骤</a></li></ul></li><li><a href="#end">END</a></li></ul><!-- /TOC --><a id="more"></a><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</p><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。  </p><p>银行家规定</p><p>(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；<br>(2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量；<br>(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；<br>(4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金.  </p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>Available数组表示剩余可用资源数</li><li>Max矩阵表示各进程对资源的最大需求数</li><li>Allocation矩阵表示各进程已分配资源数</li><li>Need矩阵表示各进程还需资源数（Need = Max - Allocation）</li><li>Request数组表示进程此次申请的各资源数</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>银行家算法：  </p><ol><li><p>检查此次申请是否超过最大需求数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request[i] &lt;= Need[i]</span><br></pre></td></tr></table></figure></li><li><p>检查此时系统升序可用资源是否满足请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Requests[i] &lt;= Available</span><br></pre></td></tr></table></figure></li><li><p>试探分配，更改数据结构中的数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available = Available - Request[i]</span><br><span class="line">Allocation = Allocation[i] + Request[i]</span><br><span class="line">Need[i] = Need[i] - Request[i]</span><br></pre></td></tr></table></figure></li><li><p>执行安全性算法检查此次分配后是否处于安全状态</p></li><li><p>若安全，正式分配，否则恢复原数值，让进程等待。</p></li></ol><p>安全性算法:  </p><ol start="6"><li><p>初始化  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work = Available     <span class="comment">//记录剩余资源</span></span><br><span class="line">Finish[i] = <span class="literal">false</span>    <span class="comment">//设定所有进程均未完成</span></span><br></pre></td></tr></table></figure></li><li><p>查找可执行进程Pi</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Finish[i] = <span class="literal">false</span>    <span class="comment">//处于未完成</span></span><br><span class="line">Need[i] &lt;= Work      <span class="comment">//剩余资源可满足需要</span></span><br></pre></td></tr></table></figure><p>有满足条件进程——跳转 3<br>无满足条件进程——跳转 4</p></li><li><p>Pi执行，完成后释放其占有资源  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Finish[i]:=<span class="literal">true</span>;    <span class="comment">//该进程一定能完成</span></span><br><span class="line">Work[j]:=Work[j]+Allocation[i,j];   <span class="comment">//归还资源，修改数值</span></span><br><span class="line">Go to <span class="built_in">step</span> <span class="number">2</span>;       <span class="comment">//跳转 2 继续查找</span></span><br></pre></td></tr></table></figure></li><li><p>如果所有进程Pi都能完成，Finish[i]=ture，则系统处于安全状态，否则系统处于不安全状态</p></li></ol><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>需要进程在运行前就知道其大小，而且进程数目不一定固定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;银行家算法是一种最有代表性的避免死锁的算法。&lt;/p&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#死锁&quot;&gt;死锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#银行家算法&quot;&gt;银行家算法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#背景&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#数据结构&quot;&gt;数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#步骤&quot;&gt;步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#end&quot;&gt;END&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从一条电线到TCP`IP</title>
    <link href="http://yoursite.com/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/"/>
    <id>http://yoursite.com/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/</id>
    <published>2020-02-24T15:45:54.000Z</published>
    <updated>2020-03-14T08:26:40.482Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av87680753?p=1" target="_blank" rel="noopener">网路基础——从一条电线到TCP/IP</a><br>今天看的这个up翻译的视频还挺有意思的，一口气看过来，复习了几个协议，感觉这个课件做的是挺好看的，直接截图下来记录了。<br>不过还是得多抓包去看去理解协议。</p><a id="more"></a><hr><p>HDLC（High-Level Data Link Control，高级数据链路控制）</p><h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/1.JPG" alt="1"></p><h2 id="ppp协议（点对点协议-Point-to-Point-Protocol-）"><a href="#ppp协议（点对点协议-Point-to-Point-Protocol-）" class="headerlink" title="ppp协议（点对点协议(Point to Point Protocol)）"></a>ppp协议（点对点协议(Point to Point Protocol)）</h2><p>常用于大型主干网络中<br><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/2.JPG" alt="1"><br><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/3.JPG" alt="1"></p><p>ipv4-32     ipv6-128  </p><p>路由：构造转发表的过程（不是每个地址都匹配，而是通过地址前缀分组）<br>转发：使用转发表转发数据的过程</p><hr><h2 id="ARP（Address-Resolution-Protocol）"><a href="#ARP（Address-Resolution-Protocol）" class="headerlink" title="ARP（Address Resolution Protocol）"></a>ARP（Address Resolution Protocol）</h2><p>地址解析协议 根据IP地址获取物理地址<br><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/4.JPG" alt="1"></p><p>IP地址决定数据包的起点和终点         MAC地址决定下一跳那个设备接收  </p><p>在IPv6中，地址解析协议的功能将由NDP（邻居发现协议，Neighbor Discovery Protocol）实现</p><p>ICMP Echo request<br>ICMP Echo reply<br><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/9.JPG" alt="1"></p><hr><h2 id="协议封装"><a href="#协议封装" class="headerlink" title="协议封装"></a>协议封装</h2><p>（俗称套娃 O__O ）<br><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/6.JPG" alt="1"></p><p>路由器 查看路由表 找到道路</p><hr><h2 id="TCP-（ransmission-Control-Protocol）"><a href="#TCP-（ransmission-Control-Protocol）" class="headerlink" title="TCP （ransmission Control Protocol）"></a>TCP （ransmission Control Protocol）</h2><p>传输控制协议 基于字节流 面向连接 可靠的<br>解决：丢包 顺序 多会话 流量控制</p><p>Protocol 为 6<br><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/7.JPG" alt="1"></p><p>三次握手建立连接 四次挥手释放资源 - -<br><img src="/2020/02/24/%E4%BB%8E%E4%B8%80%E6%9D%A1%E7%94%B5%E7%BA%BF%E5%88%B0TCP%60IP/8.JPG" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av87680753?p=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网路基础——从一条电线到TCP/IP&lt;/a&gt;&lt;br&gt;今天看的这个up翻译的视频还挺有意思的，一口气看过来，复习了几个协议，感觉这个课件做的是挺好看的，直接截图下来记录了。&lt;br&gt;不过还是得多抓包去看去理解协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>PAT-B1095-解码PAT准考证</title>
    <link href="http://yoursite.com/2020/02/23/PAT-B1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81/"/>
    <id>http://yoursite.com/2020/02/23/PAT-B1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81/</id>
    <published>2020-02-22T17:10:55.000Z</published>
    <updated>2020-02-24T22:09:11.702Z</updated>
    
    <content type="html"><![CDATA[<p>这题一开始没有想全就写了，没考虑所有的要求，导致后面重写。只要想好怎么存数据就好操作了。<br>把cin，cout改成scanf，printf，否则超时。<br>所有NA的情况一起判断。</p><a id="more"></a><hr><p>PAT 准考证号由 4 部分组成：<br>第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级；<br>第 2-4 位是考场编号，范围从 101 到 999；<br>第 5-10 位是考试日期，格式为年、月、日顺次各占 2 位；<br>最后 11-13 位是考生编号，范围从 000 到 999。<br>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。  </p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入首先在一行中给出两个正整数 N（≤10<br>​4<br>​​ ）和 M（≤100），分别为考生人数和统计要求的个数。</p><p>接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。</p><p>考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：类型 指令，其中</p><p>类型 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 指令 则给出代表指定级别的字母；<br>类型 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 指令 则给出指定考场的编号；<br>类型 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 指令 则给出指定日期，格式与准考证上日期相同。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每项统计要求，首先在一行中输出 Case #: 要求，其中 # 是该项要求的编号，从 1 开始；要求 即复制输入给出的要求。随后输出相应的统计结果：</p><p>类型 为 1 的指令，输出格式与输入的考生信息格式相同，即 准考证号 成绩。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；<br>类型 为 2 的指令，按 人数 总分 的格式输出；<br>类型 为 3 的指令，输出按人数非递增顺序，格式为 考场编号 总人数。若人数并列则按考场编号递增顺序输出。<br>如果查询结果为空，则输出 NA。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    准考证由4部分组成</span></span><br><span class="line"><span class="comment">    级别  考场     日期   编号</span></span><br><span class="line"><span class="comment">    TAB  101-999 200117</span></span><br><span class="line"><span class="comment">    case 1  指定级别 非升序输出成绩  </span></span><br><span class="line"><span class="comment">    case 2  指定考场 人数 总分</span></span><br><span class="line"><span class="comment">    case 3  指定日期 非递增输出考场人数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.首先收录所有准考证和成绩 </span></span><br><span class="line"><span class="comment">        struct node 定义结构包括一个字符串 和一个整数</span></span><br><span class="line"><span class="comment">        vector&lt;node&gt; 数组存放所有学生信息</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    2.重写cmp比较大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要求成绩按从大到小 相等时按准考号字典序从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)</span></span>&#123;<span class="comment">//引用传参</span></span><br><span class="line">    <span class="keyword">return</span> a.value!=b.value ? a.value&gt;b.value:a.t&lt;b.t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k,num; <span class="comment">//所有的输入</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;node&gt; <span class="title">v</span><span class="params">(n)</span></span>;<span class="comment">//录入信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;v[i].t&gt;&gt;v[i].value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;<span class="comment">//要求</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num&gt;&gt;s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %s\n"</span>,i,num,s.c_str());<span class="comment">//Case 1: 1 T</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; ans;<span class="comment">//记录按要求筛选的node</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>,sum=<span class="number">0</span>;<span class="comment">//case2 记录人数总分</span></span><br><span class="line">        <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:&#123;<span class="comment">//指定级别</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(v[j].t[<span class="number">0</span>]==s[<span class="number">0</span>]) ans.push_back(v[j]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;<span class="comment">//指定考场 输出人数总分 不需用ans</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(v[j].t.substr(<span class="number">1</span>,<span class="number">3</span>)==s)&#123;</span><br><span class="line">                                cnt++;sum+=v[j].value;</span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125;<span class="comment">//有的话直接输出 没有最后统一NA</span></span><br><span class="line">                        <span class="keyword">if</span>(cnt!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,cnt,sum);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                            <span class="keyword">if</span>(v[j].t.substr(<span class="number">4</span>,<span class="number">6</span>)==s) m[v[j].t.substr(<span class="number">1</span>,<span class="number">3</span>)]++;</span><br><span class="line">                        <span class="comment">//将m中的 node付给ans</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> it:m) ans.push_back(&#123;it.first,it.second&#125;);    </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++) <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, ans[j].t.c_str(), ans[j].value);</span><br><span class="line">        <span class="keyword">if</span> (((num == <span class="number">1</span> || num == <span class="number">3</span>) &amp;&amp; ans.<span class="built_in">size</span>() == <span class="number">0</span>) || (num == <span class="number">2</span> &amp;&amp; cnt == <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/23/PAT-B1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81/1.JPG" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题一开始没有想全就写了，没考虑所有的要求，导致后面重写。只要想好怎么存数据就好操作了。&lt;br&gt;把cin，cout改成scanf，printf，否则超时。&lt;br&gt;所有NA的情况一起判断。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT" scheme="http://yoursite.com/categories/PAT/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>开心！</title>
    <link href="http://yoursite.com/2020/02/21/%E5%BC%80%E5%BF%83%EF%BC%81/"/>
    <id>http://yoursite.com/2020/02/21/%E5%BC%80%E5%BF%83%EF%BC%81/</id>
    <published>2020-02-21T10:45:54.000Z</published>
    <updated>2020-02-22T11:24:41.001Z</updated>
    
    <content type="html"><![CDATA[<p>中午睡了会儿醒来居然提前出了，给我一个惊喜，数学比考完预想要低一点，其他稳定发挥，接下来继续准备复试!</p><p><img src="/2020/02/21/%E5%BC%80%E5%BF%83%EF%BC%81/1.JPG" alt="1"></p><p>复习这一年眼看着考研群里的人从一百慢慢上涨，考研的人越来越多，希望一战成硕！keep going！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中午睡了会儿醒来居然提前出了，给我一个惊喜，数学比考完预想要低一点，其他稳定发挥，接下来继续准备复试!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/21/%E5%BC%80%E5%BF%83%EF%BC%81/1.JPG&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;复习这一年
      
    
    </summary>
    
    
      <category term="none" scheme="http://yoursite.com/categories/none/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT-B1058-B1073-多选题</title>
    <link href="http://yoursite.com/2020/02/19/PAT-B1058-B1073-%E5%A4%9A%E9%80%89%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/19/PAT-B1058-B1073-%E5%A4%9A%E9%80%89%E9%A2%98/</id>
    <published>2020-02-18T17:10:55.000Z</published>
    <updated>2020-02-21T18:55:21.027Z</updated>
    
    <content type="html"><![CDATA[<p>印象中这道题很早就写过，考研前，当时在用C做题，有三个点过不去代码看着也乱，没有做完整其实是思路不清晰。<br>后来重做感觉这道题的小坑主要控是制好输入的题目以及题解，判断过程还算简单。</p><a id="more"></a><hr><h2 id="B1073-多选题常见计分法-20分"><a href="#B1073-多选题常见计分法-20分" class="headerlink" title="B1073 多选题常见计分法 (20分)"></a>B1073 多选题常见计分法 (20分)</h2><p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1073 多选题常见计分法 (20分)</span></span><br><span class="line"><span class="comment">    自己的思路与网上的题解一样 但是刚开始没有完整写出来  </span></span><br><span class="line"><span class="comment">    看了部分题解后再捋一遍就好多了</span></span><br><span class="line"><span class="comment">    思路清晰 就好！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> tol;<span class="comment">//满分值 不超过5的正整数</span></span><br><span class="line">    <span class="keyword">int</span> cnt;<span class="comment">//选项个数 (2-5)个</span></span><br><span class="line">    <span class="keyword">int</span> rcnt;<span class="comment">//正确选项个数</span></span><br><span class="line">    <span class="keyword">int</span> opt[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//正确选项</span></span><br><span class="line">&#125;s[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> err[<span class="number">100</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//放错误选项</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> ans[<span class="number">5</span>],<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( s[j].opt[i] &amp;&amp; (!ans[i]) ) </span><br><span class="line">            err[j][i]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( (!s[j].opt[i]) &amp;&amp; ans[i] )&#123;</span><br><span class="line">            err[j][i]++;sign=<span class="number">1</span>;  </span><br><span class="line">        &#125;                    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( s[j].opt[i] &amp;&amp; ans[i]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sign) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt==s[j].rcnt) <span class="keyword">return</span> s[j].tol;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt!=s[j].rcnt) <span class="keyword">return</span> s[j].tol/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;<span class="comment">//学生人数 多选题个数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">char</span> temp;<span class="comment">//字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录题目信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i].tol &gt;&gt; s[i].cnt &gt;&gt; s[i].rcnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i].rcnt; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            s[i].opt[temp-<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">// 学生分数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp &gt;&gt; a;   <span class="comment">//用temp接收括号 a接收选项</span></span><br><span class="line">            <span class="keyword">int</span> ans[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a; k++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">                ans[temp - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            score += judge(ans,j);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找最大</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">            <span class="built_in">max</span> = err[i][j] &gt; <span class="built_in">max</span> ? err[i][j] : <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(err[i][j] == <span class="built_in">max</span>)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; (<span class="keyword">char</span>)(j+<span class="string">'a'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Too simple"</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/19/PAT-B1058-B1073-%E5%A4%9A%E9%80%89%E9%A2%98/1.JPG" alt="1"></p><p>做完1073再看1058简单很多，只有全对才能拿分，实现过程是一样的。</p><hr><h2 id="B1058-选择题-20分"><a href="#B1058-选择题-20分" class="headerlink" title="B1058 选择题 (20分)"></a>B1058 选择题 (20分)</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入在第一行给出两个正整数 N（≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1058 选择题 (20分)</span></span><br><span class="line"><span class="comment">和1073一个意思 只是 这个必须全对才拿分 相比更简单一点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tol;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> rcnt;</span><br><span class="line">    <span class="keyword">int</span> opt[<span class="number">5</span>];</span><br><span class="line">&#125;s[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> err[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> ans[<span class="number">5</span>],<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(ans[i] != s[j].opt[i]) sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">        err[j]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[j].tol; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s[i].tol&gt;&gt;s[i].cnt&gt;&gt;s[i].rcnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i].rcnt;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">            s[i].opt[temp - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> score,a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;temp&gt;&gt;a;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;a;k++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">                ans[temp - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">            score += judge(ans,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">        <span class="built_in">max</span> = err[i]&gt;<span class="built_in">max</span>? err[i] :<span class="built_in">max</span>; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++) </span><br><span class="line">            <span class="keyword">if</span>(err[i]==<span class="built_in">max</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;i+<span class="number">1</span> ;  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Too simple"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/19/PAT-B1058-B1073-%E5%A4%9A%E9%80%89%E9%A2%98/2.JPG" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;印象中这道题很早就写过，考研前，当时在用C做题，有三个点过不去代码看着也乱，没有做完整其实是思路不清晰。&lt;br&gt;后来重做感觉这道题的小坑主要控是制好输入的题目以及题解，判断过程还算简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT" scheme="http://yoursite.com/categories/PAT/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数学问题" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>共享单车小程序开发总结</title>
    <link href="http://yoursite.com/2020/02/16/%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/02/16/%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-16T10:45:54.000Z</published>
    <updated>2020-03-14T08:37:33.556Z</updated>
    
    <content type="html"><![CDATA[<hr><p>今天看网课学到一句名言，感慨一下……  </p><p>The mind is not a vessel to be filled, but a fire to be kindled.&emsp;&emsp;—— Plutarch  </p><p>说得真好，确实是这样，所有坚持的事情，那些个日日夜夜，并不是在乎“容器”里的得失，而是因为有了心中的那团火焰。</p><a id="more"></a><hr><p>图床居然崩了，还好看了一下……</p><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><h3 id="初始界面，定位"><a href="#初始界面，定位" class="headerlink" title="初始界面，定位"></a>初始界面，定位</h3><p><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/EpnZ2Lm61bRtWOHnS20OT*mrzeNnic.L.BSfg.k.V7vYYiLBT42M7fgi6MX2YPCzvgVAovV4AAoW8Zl9oUFFuA!!/b&bo=6QD0AQAAAAACBz8!&rf=viewer_4" alt="Markdown"></p><h3 id="点击扫码开锁，进入注册"><a href="#点击扫码开锁，进入注册" class="headerlink" title="点击扫码开锁，进入注册"></a>点击扫码开锁，进入注册</h3><p><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/Af1yGqSdppVqA7I0*cpgDPdpAwl6V8MsbV59carZecoUkalIosSCDRTRVdCNsdIQFltRqVJUrdIjMgj1P1AnZjy96Vfk.kEnsI6lRI0maHk!/b&bo=6QD0AQAAAAACh78!&rf=viewer_4" alt="Markdown"></p><h3 id="押金和实名认证"><a href="#押金和实名认证" class="headerlink" title="押金和实名认证"></a>押金和实名认证</h3><p><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/Af1yGqSdppVqA7I0*cpgDEYGZYfGSmSDvpdE3cVCgHkIFxmaZx1vkB0u6wRGo5bHDDT1w2.zr7JE.qF7eJkoIzeBHTNgp8s8UU1bdCP67Hw!/b&bo=6QD0AQAAAAACh78!&rf=viewer_4" alt="Markdown"></p><h3 id="查找附近单车和添加单车"><a href="#查找附近单车和添加单车" class="headerlink" title="查找附近单车和添加单车"></a>查找附近单车和添加单车</h3><p><img src="http://m.qpic.cn/psc?/V12eGGFP2qg1dh/Af1yGqSdppVqA7I0*cpgDNSLKNhx.9o.hL7FYtahR8oq6RQVlVqpQ7RWznB2gSEOH7fTMKS9S9cVUyT33QRvoCLJ7sMv*Xje.ouOOKGWF4U!/b&bo=6QD0AQAAAAACl68!&rf=viewer_4" alt="Markdown"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次做微信小程序，牛客网的项目，跟着做下来学习了一些知识，锻炼了动手能力，要完全消化理解还需要继续深入学习，过程中遇到问题卡住，孤独的查文档和博客的景象历历在目 T_T </p><p>总结一下，项目主要进行了<br>1.小程序相关组件实现前台界面 weui<br>2.SpringBoot框架实现后台程序，初识SpringBoot，真的是开箱即用了-_-<br>3.短信接口用了腾讯云的<br>4.redis用来存储检验验证码<br>5.MongoDB数据库保存users和bikes的信息<br>6.支付和实名的两个request都是模拟的，只是保存了信息没有调用支付认证的API<br>7.MongoDB的Geo索引实现只查找一定范围内的单车  </p><p>一些图标从<a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2" target="_blank" rel="noopener">iconfont</a>找的<br>源码已上传<a href="https://github.com/Alvin103/bike" target="_blank" rel="noopener">github</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;今天看网课学到一句名言，感慨一下……  &lt;/p&gt;
&lt;p&gt;The mind is not a vessel to be filled, but a fire to be kindled.&amp;emsp;&amp;emsp;—— Plutarch  &lt;/p&gt;
&lt;p&gt;说得真好，确实是这样，所有坚持的事情，那些个日日夜夜，并不是在乎“容器”里的得失，而是因为有了心中的那团火焰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯云短信接口实现手机验证码</title>
    <link href="http://yoursite.com/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://yoursite.com/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2020-02-14T17:31:04.000Z</published>
    <updated>2020-02-21T17:06:47.587Z</updated>
    
    <content type="html"><![CDATA[<p>终于用腾讯云短信接口实现了短信注册码！ 一路摸索，好在柳暗花明，遇到的问题最终都解决了。  </p><p><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/1.JPG" alt="1"></p><a id="more"></a><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="腾讯云短信"><a href="#腾讯云短信" class="headerlink" title="腾讯云短信"></a>腾讯云短信</h3><p>注册腾讯云账号使用短信服务，相信很多跟我一样都卡在了申请短信签名这里<br><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/2.JPG" alt="1"><br>没有符合的申请要求，没有上线的小程序和公众号^_^,几乎放弃，想再找找其他免费的短信服务。<br>灵机一动，想到了之前做个人公众号的舍友 BigSakana。</p><p>于是愉快的申请好了签名和正文，之后就可以行动了！<br><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/4.JPG" alt="1"></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis是一个开源的用C编写的高性能key-value数据库!<br><a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">github下载（需梯子）</a>&emsp;&emsp;&emsp;&emsp;<a href="https://pan.baidu.com/s/1i56thcD?fid=736886225509949" target="_blank" rel="noopener">百度云下载</a><br>下好后添加环境变量 控制台输入启动Redis  </p><pre><code>redis-cli.exe   //启动set test 111    //添加key名为test 键值为111的数据keys *          //查看所有get test        //找key对应valuedel test        //删除</code></pre><p><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/5.JPG" alt="1"><br>还可以设置超时时间等</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- 腾讯云短信依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.qcloudsms<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qcloudsms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis 依赖 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a>发送短信</h2><p><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/6.JPG" alt="1"><br>流程:<br>当用户输入手机号点击获取验证码，小程序向后台发送请求，后台向提供短信服务的运营商发出请求，然后短信运营商给手机用户发送短信。后台会把手机号和验证码存到Redis中，并设置超时时间。</p><p><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/7.JPG" alt="1"></p><h3 id="用户类代码"><a href="#用户类代码" class="headerlink" title="用户类代码"></a>用户类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.alvin.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.alvin.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span><span class="comment">//标记Controller 用于处理用户请求和响应 Spring管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="comment">//接收用户请求的参数并且将相应的数据响应给用户</span></span><br><span class="line"><span class="meta">@Autowired</span><span class="comment">//按类型注入</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;<span class="comment">//引用接口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/genCode"</span>)<span class="comment">//与小程序的请求一致</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">genVerifyCode</span><span class="params">(String nationCode, String phoneNum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = userService.sendMsg(nationCode, phoneNum);<span class="comment">//sendMsg方法传递用户输入的国家编码和电话号码</span></span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service类代码"><a href="#service类代码" class="headerlink" title="service类代码"></a>service类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.alvin.service;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit; </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.qcloudsms.SmsSingleSender; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span><span class="comment">//Spring注解 标记这个类被Spring容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMsg</span><span class="params">(String nationCode, String phoneNum)</span> </span>&#123;    <span class="comment">//方法的实现</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 调用腾讯云的短信API</span></span><br><span class="line"><span class="keyword">int</span> appid = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">"appid"</span>));</span><br><span class="line">String appkey = stringRedisTemplate.opsForValue().get(<span class="string">"appkey"</span>);</span><br><span class="line"><span class="comment">//生成一个随机数字（4位）</span></span><br><span class="line">String code = (<span class="keyword">int</span>)(Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">1000</span> - <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//String[] params = &#123;"5678"&#125;;</span></span><br><span class="line"><span class="comment">//String code = "5678";</span></span><br><span class="line">SmsSingleSender ssender = <span class="keyword">new</span> SmsSingleSender(appid, appkey);</span><br><span class="line"><span class="comment">//向对应手机号的用户发送短信</span></span><br><span class="line">        ssender.send(<span class="number">0</span>, nationCode, phoneNum, <span class="string">"【BigSakana】您的注册验证码为"</span>+code, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//将发送的手机号作为key，验证码作为value保存到Redis中</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(phoneNum, code, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//异常</span></span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h3><p>配置文件中填写Redis的链接信息</p><pre><code>#redisspring.redis.host=localhostspring.redis.port=6379spring.redis.pool.max-active=20spring.redis.pool.max-idle=10spring.redis.pool.min-idle=5spring.redis.pool.max-wait=-1</code></pre><p>已在Redis里添加了appid和appkey (腾讯云短信服务的应用)<br><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/8.JPG" alt="1">  </p><p>之后启动，测试，成功，取得阶段性胜利^_^！<br><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/12.JPG" alt="1">  </p><hr><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/9.JPG" alt="1"><br>可以看到，开始测试了很多回没有成功，调试过程中小程序确实显示向后端发出了请求，后端也没有异常，很是为啥就是发不出短信呢，查看腾讯云的业务统计知道了是签名的原因。既然审批通过了肯定是格式的问题，不过知道了也不清楚怎么办，于是看开发指南开始试！  </p><p> （后来知道其实发不出的原因就是没把签名写到发送内容里）</p><p>刚开始我用的是 ssender.send 方法，五个参数类型都是String 。 </p><pre><code>ssender.send(0, nationCode, phoneNum, &quot;您的注册验证码为&quot;+code, &quot;&quot;, &quot;&quot;);</code></pre><p><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/10.JPG" alt="1"> </p><p>后来换成文档实例的 ssender.sendWithParam 方法。</p><pre><code>ssender.sendWithParam(nationCode, phoneNum,templateId, params, smsSign, &quot;&quot;, &quot;&quot;);//templateId 正文模板id//params     参数//smsSign    签名</code></pre><p><img src="/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/11.JPG" alt="1"><br>注意这个方法的第三个参数类型是ArrayList&lt; String &gt; ，之前声明的是String类型，需要修改下。</p><p>sendWithParam()方法把签名作为一个参数，发送成功了。于是换回send()，这次加上了签名在内容里，也成功了！</p><pre><code>ssender.send(0, nationCode, phoneNum, &quot;【BigSakana】您的注册验证码为&quot;+code, &quot;&quot;, &quot;&quot;);</code></pre><p>参考了<a href="https://cloud.tencent.com/document/product/382/13613" target="_blank" rel="noopener">官方的开发指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于用腾讯云短信接口实现了短信注册码！ 一路摸索，好在柳暗花明，遇到的问题最终都解决了。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/1.JPG&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>PAT-1025-反转链表</title>
    <link href="http://yoursite.com/2020/02/12/PAT-B1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/12/PAT-B1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-12T07:46:22.000Z</published>
    <updated>2020-02-21T17:10:07.299Z</updated>
    
    <content type="html"><![CDATA[<p>静态链表，通过数组模拟，数组下标表示地址。<br>结点定义 需要加一个标记 因为可能给出不连在链表里的结点。<br>注意最后不足K个不反转。</p><p>1.可通过按标记排序把所有结点放到前面,控制输出完成逆序</p><pre><code>struct Node {    int adress, data, next;    int order;  //结点在链表上的序号 无效记为maxn } node[maxn];</code></pre><p>2.也可以模拟链表真实进行反转，</p><pre><code>typedef struct Node{    int address;    int num;    int next;    struct Node *link;}LNode, *Pin;</code></pre><a id="more"></a><hr><p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤105)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。<br>接下来有 N 行，每行格式为：<br>Address Data Next<br>其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。<br><img src="/2020/02/12/PAT-B1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.JPG" alt="1"></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adress, data, next;</span><br><span class="line">    <span class="keyword">int</span> order;  <span class="comment">//结点在链表上的序号 无效记为maxn</span></span><br><span class="line">&#125; node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.order &lt; b.order;   <span class="comment">//按 order 从小到大排列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) node[i].order = maxn; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span>, n, k, adress;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; <span class="built_in">begin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">//记录数据</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;adress;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[adress].data &gt;&gt; node[adress].next;</span><br><span class="line">        node[adress].adress = adress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">begin</span>, count = <span class="number">0</span>;   <span class="comment">//count 记录有效结点数目</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span>) &#123;    <span class="comment">//遍历标记所有有效结点</span></span><br><span class="line">        node[p].order = count++;</span><br><span class="line">        p = node[p].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(node, node + maxn, cmp);   <span class="comment">//整个按order从头到尾排序</span></span><br><span class="line">    n = count;  <span class="comment">//排序后前count个是有效结点 书写方便 把count赋给 n</span></span><br><span class="line">    <span class="comment">//输出  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / k; i++) &#123; <span class="comment">//分块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = (i + <span class="number">1</span>) * k - <span class="number">1</span>; j &gt; i * k; j--) <span class="comment">//逆序输出  </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, node[j].adress, node[j].data, node[j<span class="number">-1</span>].adress);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, node[i * k].adress, node[i * k].data); <span class="comment">//每一块的衔接结点单独控制  </span></span><br><span class="line">        <span class="comment">//若不是最后一个衔接点 输出的next地址为下一块的末尾地址</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; n / k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, node[(i + <span class="number">2</span>) * k - <span class="number">1</span>].adress);</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//整除</span></span><br><span class="line">            <span class="keyword">if</span>(n % k == <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//最后一块若不到K个元素不反转</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, node[(i + <span class="number">1</span>) * k].adress);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = n / k * k; i&lt; n; i++) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, node[i].adress, node[i].data);</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, node[i + <span class="number">1</span>].adress);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/PAT-B1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.JPG" alt="1"></p><p>以前用c写的模拟逆转链表  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="comment">//链表结构：当前地址 值 下一个结点的地址 指向下一结点的指针 </span></span><br><span class="line"><span class="keyword">int</span> address;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;LNode, *Pin; </span><br><span class="line"></span><br><span class="line"><span class="function">Pin <span class="title">Reversed</span><span class="params">(Pin p,<span class="keyword">int</span> k)</span></span>;  <span class="comment">//反转链表 参数1头结点 2长度k </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPin</span><span class="params">(Pin p)</span></span>;<span class="comment">//输出链表 参数头结点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,Len=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//创建的链表结点数</span></span><br><span class="line"><span class="keyword">int</span> data[MAX_SIZE];<span class="comment">//存数据 </span></span><br><span class="line"><span class="keyword">int</span> next[MAX_SIZE];<span class="comment">//存指向的地址 </span></span><br><span class="line"><span class="keyword">int</span> temp;<span class="comment">//临时变量 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;N,&amp;Len,&amp;k); <span class="comment">//输入 第一个地址N 结点数Len 长度k </span></span><br><span class="line">LNode a[Len+<span class="number">1</span>];<span class="comment">//能存Len+1个结点的数组 </span></span><br><span class="line">a[<span class="number">0</span>].next = N;  <span class="comment">//a[0]作为头结点 无数据</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; Len+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);<span class="comment">//先读入地址  </span></span><br><span class="line"><span class="comment">//在这里地址的数组内存 数据放到data[]里  指向的地址放next[]</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;data[temp],&amp;next[temp]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建单链表</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i<span class="number">-1</span>].next == <span class="number">-1</span>)&#123;<span class="comment">//如果到最后一个结点 将next设为NULL </span></span><br><span class="line">a[i<span class="number">-1</span>].link = <span class="literal">NULL</span>;</span><br><span class="line">num = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[i].address = a[i<span class="number">-1</span>].next;</span><br><span class="line">a[i].num = data[a[i].address];</span><br><span class="line">a[i].next = next[a[i].address];</span><br><span class="line">a[i<span class="number">-1</span>].link = &amp;a[i]; </span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pin p = a;<span class="comment">//指向链表头结点 是空的 </span></span><br><span class="line">Pin rp = <span class="literal">NULL</span>;<span class="comment">//反转链表 开始设为NULL </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k &lt;= num)&#123; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(num/k);i++)&#123;<span class="comment">//num/k 得到反转的段数 </span></span><br><span class="line">rp = Reversed(p,k);<span class="comment">//rp接收反转链表函数的返回值 </span></span><br><span class="line">p-&gt;link = rp;<span class="comment">//反转后的接到p后面 </span></span><br><span class="line">p-&gt;next = rp-&gt;address;<span class="comment">//更改下一个结点的地址 是rp的第一地址 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;k)&#123;<span class="comment">//使p指向下一个段 移动p直到j==k </span></span><br><span class="line">p = p-&gt;link;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintPin(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Pin <span class="title">Reversed</span><span class="params">(Pin p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">Pin New = p-&gt;link;<span class="comment">//New 是p的下一个 </span></span><br><span class="line">Pin old = New-&gt;link;<span class="comment">//old 是p的下下个 </span></span><br><span class="line">Pin tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(count &lt; k)&#123;</span><br><span class="line">tmp = old-&gt;link;<span class="comment">//tmp存old后一个 </span></span><br><span class="line">old-&gt;link = New;<span class="comment">//old逆转 指向前一个 也就是new指的那个结点 </span></span><br><span class="line">old-&gt;next = New-&gt;address;</span><br><span class="line">New = old;<span class="comment">//new 变为后面一个 </span></span><br><span class="line">old = tmp;<span class="comment">//old 变为后面一个 </span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;link-&gt;link = old;<span class="comment">//逆转后的末尾接上old </span></span><br><span class="line"><span class="keyword">if</span>(old != <span class="literal">NULL</span>)&#123;</span><br><span class="line">p-&gt;link-&gt;next = old-&gt;address;<span class="comment">//末尾的next值更新 </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p-&gt;link-&gt;next = <span class="number">-1</span>;<span class="comment">//若是最后 更新尾指针为-1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> New;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPin</span><span class="params">(Pin s)</span></span>&#123;</span><br><span class="line">Pin p = s;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;link != <span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.5d %d %.5d\n"</span>,p-&gt;address,p-&gt;num,p-&gt;next);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.5d %d %d\n"</span>,p-&gt;address,p-&gt;num,p-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态链表，通过数组模拟，数组下标表示地址。&lt;br&gt;结点定义 需要加一个标记 因为可能给出不连在链表里的结点。&lt;br&gt;注意最后不足K个不反转。&lt;/p&gt;
&lt;p&gt;1.可通过按标记排序把所有结点放到前面,控制输出完成逆序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct Node {
    int adress, data, next;
    int order;  //结点在链表上的序号 无效记为maxn 
} node[maxn];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.也可以模拟链表真实进行反转，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct Node{
    int address;
    int num;
    int next;
    struct Node *link;
}LNode, *Pin;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="PAT" scheme="http://yoursite.com/categories/PAT/"/>
    
    
      <category term="ds" scheme="http://yoursite.com/tags/ds/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>PAT-分数四则运算-B1034-A1088</title>
    <link href="http://yoursite.com/2020/02/12/PAT-B1034-A1088-%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/02/12/PAT-B1034-A1088-%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</id>
    <published>2020-02-12T07:09:00.000Z</published>
    <updated>2020-02-21T17:41:52.664Z</updated>
    
    <content type="html"><![CDATA[<p>假分数的表示和化简，四则运算，控制输出。<br>代码虽长但是分成每个问题逐一解决。</p><a id="more"></a><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。</p><p><img src="/2020/02/12/PAT-B1034-A1088-%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/2.JPG" alt="1"></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//有理数四则运算</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;   <span class="comment">//int int 相乘 最大可达到 long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;    <span class="comment">//辗转相除法求最大公约数</span></span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span> &#123;</span><span class="comment">//分数</span></span><br><span class="line">    ll up, down;<span class="comment">//分子分母</span></span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="comment">/*  1. 分数为负数使分子为负</span></span><br><span class="line"><span class="comment">    2. 分数为0 分子为 0 分母为 1</span></span><br><span class="line"><span class="comment">    3. 分子和分母没有除 1 以外的公约数（也就是化最简）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.down &lt; <span class="number">0</span>) &#123;   <span class="comment">//分母为负 令上下都变为相反数</span></span><br><span class="line">        result.up = -result.up;</span><br><span class="line">        result.down = -result.down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.up == <span class="number">0</span>)  &#123;   <span class="comment">//分子为 0 令分母为1</span></span><br><span class="line">        result.down = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//分子不为 0 约分 找公约数相除</span></span><br><span class="line">        <span class="keyword">int</span> d = gcd(<span class="built_in">abs</span>(result.up), <span class="built_in">abs</span>(result.down));</span><br><span class="line">        result.up /= d;</span><br><span class="line">        result.down /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;    <span class="comment">//加法</span></span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.down + f1.down * f2.up;</span><br><span class="line">    result.down = f1.down * f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">minu</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;   <span class="comment">//减法</span></span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.down - f1.down * f2.up;</span><br><span class="line">    result.down = f1.down * f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">multi</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;  <span class="comment">//乘法</span></span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.up;</span><br><span class="line">    result.down = f1.down * f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">divide</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;<span class="comment">//除法</span></span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.down;</span><br><span class="line">    result.down = f1.down * f2.up;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">(Fraction r)</span> </span>&#123;   <span class="comment">//输出分数 r</span></span><br><span class="line">    r = reduction(r);</span><br><span class="line">    <span class="keyword">if</span>(r.up&lt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    <span class="keyword">if</span>(r.down == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld"</span>, r.up);   <span class="comment">//整数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(r.up) &gt; r.down) &#123;           <span class="comment">//假分数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld/%lld"</span>, r.up / r.down, <span class="built_in">abs</span>(r.up) % r.down, r.down);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;                                 <span class="comment">//真分数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, r.up, r.down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r.up&lt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld/%lld %lld/%lld"</span>, &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down);</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    showResult(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" + "</span>;</span><br><span class="line">    showResult(b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" = "</span>;</span><br><span class="line">    showResult(add(a, b));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    showResult(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" - "</span>;</span><br><span class="line">    showResult(b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" = "</span>;</span><br><span class="line">    showResult(minu(a, b));  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//乘</span></span><br><span class="line">    showResult(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" * "</span>;</span><br><span class="line">    showResult(b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" = "</span>;</span><br><span class="line">    showResult(multi(a, b));  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//除</span></span><br><span class="line">    showResult(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" / "</span>;</span><br><span class="line">    showResult(b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" = "</span>;</span><br><span class="line">    <span class="keyword">if</span>(b.up == <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Inf"</span>; <span class="comment">//特殊情况 除数为0</span></span><br><span class="line">    <span class="keyword">else</span>    showResult(divide(a, b)); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负号只加在分子上<br>化简的细节，考虑所有的情况<br>数据范围要用long long int乘法会溢出<br>求最大公约数时加绝对值<br>除数0时需要特别处理  </p><p><img src="/2020/02/12/PAT-B1034-A1088-%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/1.JPG" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假分数的表示和化简，四则运算，控制输出。&lt;br&gt;代码虽长但是分成每个问题逐一解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT" scheme="http://yoursite.com/categories/PAT/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数学问题" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>BJFUOJ-(263-272)-BinaryTree</title>
    <link href="http://yoursite.com/2020/02/12/BJFUOJ-(263-272)-BinaryTree/"/>
    <id>http://yoursite.com/2020/02/12/BJFUOJ-(263-272)-BinaryTree/</id>
    <published>2020-02-12T04:14:05.000Z</published>
    <updated>2020-02-17T14:16:47.339Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.bjfuacm.com/structure?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&page=1" target="_blank" rel="noopener">BJFUOJ | Data Structure</a></p><!-- TOC --><ul><li><a href="#主体-二叉树结点定义按给定先序建树以及删除">主体 二叉树结点定义，按给定先序建树以及删除</a></li><li><a href="#263-基于二叉链表的二叉树结构相等的判断">(263) 基于二叉链表的二叉树结构相等的判断</a></li><li><a href="#264-基于二叉链表的二叉树左右孩子的交换">(264) 基于二叉链表的二叉树左右孩子的交换</a></li><li><a href="#265269-基于二叉链表的二叉树前中后双序遍历-递归">(265&amp;269) 基于二叉链表的二叉树前中后双序遍历 （递归）</a></li><li><a href="#266-基于二叉链表的二叉树最大宽度">(266) 基于二叉链表的二叉树最大宽度</a></li><li><a href="#267271-基于二叉链表的二叉树最长路径--高度">(267&amp;271) 基于二叉链表的二叉树最长路径  高度</a></li><li><a href="#268-基于二叉链表的二叉树叶子结点到根节点的路径">(268) 基于二叉链表的二叉树叶子结点到根节点的路径</a></li><li><a href="#270-基于二叉链表的二叉树统计度为-0-1-2-结点个数">(270) 基于二叉链表的二叉树统计度为 0 1 2 结点个数</a></li><li><a href="#272-基于二叉链表的二叉树表达式求值">(272) 基于二叉链表的二叉树表达式求值</a></li></ul><!-- /TOC --><p>复习了树的相关知识，模拟建树，绝知此事要躬行！很多方法要求递归实现，在写递归时，要注意边界条件，递归的前进段、返回段。在脑中模拟出递归的流程。</p><a id="more"></a><hr><h2 id="主体-二叉树结点定义，按给定先序建树以及删除"><a href="#主体-二叉树结点定义，按给定先序建树以及删除" class="headerlink" title="主体 二叉树结点定义，按给定先序建树以及删除"></a>主体 二叉树结点定义，按给定先序建树以及删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结点    BinTree代表指向一个TNode的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    TNode* lchild;</span><br><span class="line">    TNode* rchild;</span><br><span class="line">&#125;*BinTree;</span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Create</span><span class="params">(<span class="built_in">string</span> &amp;a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Det</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreT</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InT</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PosT</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTTwice</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Heigh</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D0</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D1</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D2</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Path0</span><span class="params">(BinTree T, <span class="keyword">char</span> path[], <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PathMax</span><span class="params">(BinTree T, <span class="keyword">char</span> path[], <span class="keyword">int</span> len, <span class="keyword">bool</span> &amp;first, <span class="keyword">int</span> <span class="built_in">height</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLevelWidth</span><span class="params">(BinTree T, <span class="keyword">int</span> level)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Width</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(BinTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(BinTree T1, BinTree T2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用函数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  按给定 先序遍历 递归建立二叉树 </span></span><br><span class="line"><span class="function">BinTree <span class="title">Create</span><span class="params">(<span class="built_in">string</span> &amp;a)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;       <span class="comment">//'0'表示结点为空</span></span><br><span class="line">    BinTree T = <span class="keyword">new</span> TNode;</span><br><span class="line">    T-&gt;data = a[<span class="number">0</span>];</span><br><span class="line">    a = a.substr(<span class="number">1</span>);</span><br><span class="line">    T-&gt;lchild = Create(a);</span><br><span class="line">    a = a.substr(<span class="number">1</span>);</span><br><span class="line">    T-&gt;rchild = Create(a);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除树 递归free所有结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Det</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        Det(T-&gt;lchild);</span><br><span class="line">        Det(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="263-基于二叉链表的二叉树结构相等的判断"><a href="#263-基于二叉链表的二叉树结构相等的判断" class="headerlink" title="(263) 基于二叉链表的二叉树结构相等的判断"></a>(263) 基于二叉链表的二叉树结构相等的判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(BinTree T1, BinTree T2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T1 &amp;&amp; T2) &#123;          <span class="comment">//列出不等的条件</span></span><br><span class="line">        <span class="keyword">if</span>(T1-&gt;data != T2-&gt;data) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Check(T1-&gt;lchild, T2-&gt;lchild)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Check(T1-&gt;rchild, T2-&gt;rchild)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> T1 == T2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="264-基于二叉链表的二叉树左右孩子的交换"><a href="#264-基于二叉链表的二叉树左右孩子的交换" class="headerlink" title="(264) 基于二叉链表的二叉树左右孩子的交换"></a>(264) 基于二叉链表的二叉树左右孩子的交换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(BinTree T)</span> </span>&#123;      <span class="comment">//递归实现</span></span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    BinTree p = T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild = T-&gt;lchild;</span><br><span class="line">    T-&gt;lchild = p;</span><br><span class="line">    Swap(T-&gt;lchild);</span><br><span class="line">    Swap(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="265-amp-269-基于二叉链表的二叉树前中后双序遍历-（递归）"><a href="#265-amp-269-基于二叉链表的二叉树前中后双序遍历-（递归）" class="headerlink" title="(265&amp;269) 基于二叉链表的二叉树前中后双序遍历 （递归）"></a>(265&amp;269) 基于二叉链表的二叉树前中后双序遍历 （递归）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实质是控制第几次访问时输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreT</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">    PreT(T-&gt;lchild);</span><br><span class="line">    PreT(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InT</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    InT(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">    InT(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PosT</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    PosT(T-&gt;lchild);</span><br><span class="line">    PosT(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTTwice</span><span class="params">(BinTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">    PreTTwice(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">    PreTTwice(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="266-基于二叉链表的二叉树最大宽度"><a href="#266-基于二叉链表的二叉树最大宽度" class="headerlink" title="(266) 基于二叉链表的二叉树最大宽度"></a>(266) 基于二叉链表的二叉树最大宽度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLevelWidth</span><span class="params">(BinTree T, <span class="keyword">int</span> level)</span> </span>&#123;   <span class="comment">//计算指定层的宽度 递归 </span></span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(level == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> GetLevelWidth(T-&gt;lchild, level - <span class="number">1</span>) + GetLevelWidth(T-&gt;rchild, level - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Width</span><span class="params">(BinTree T)</span> </span>&#123;      <span class="comment">//取最大宽度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> H = Heigh(T);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= H; i++) &#123;</span><br><span class="line">        <span class="built_in">width</span> = GetLevelWidth(T, i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">width</span> &gt; <span class="built_in">max</span>) <span class="built_in">max</span> = <span class="built_in">width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="267-amp-271-基于二叉链表的二叉树最长路径-高度"><a href="#267-amp-271-基于二叉链表的二叉树最长路径-高度" class="headerlink" title="(267&amp;271) 基于二叉链表的二叉树最长路径  高度"></a>(267&amp;271) 基于二叉链表的二叉树最长路径  高度</h2><p>求最长路径要用到树高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PathMax</span><span class="params">(BinTree T, <span class="keyword">char</span> path[], <span class="keyword">int</span> len, <span class="keyword">bool</span> &amp;first, <span class="keyword">int</span> <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(first &amp;&amp; len + <span class="number">1</span> == <span class="built_in">height</span>) &#123;    <span class="comment">//最长路径长度等于二叉树高度 此时顺序输出path内容即为路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">cout</span> &lt;&lt; path[i];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//将走过结点放入path数组 递归寻找最长路径</span></span><br><span class="line">        path[len++] = T-&gt;data;</span><br><span class="line">        PathMax(T-&gt;lchild, path, len, first, <span class="built_in">height</span>);</span><br><span class="line">        PathMax(T-&gt;rchild, path, len, first, <span class="built_in">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="268-基于二叉链表的二叉树叶子结点到根节点的路径"><a href="#268-基于二叉链表的二叉树叶子结点到根节点的路径" class="headerlink" title="(268) 基于二叉链表的二叉树叶子结点到根节点的路径"></a>(268) 基于二叉链表的二叉树叶子结点到根节点的路径</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Path0</span><span class="params">(BinTree T, <span class="keyword">char</span> path[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) &#123;   <span class="comment">//遇到叶子结点 输出路径</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">cout</span> &lt;&lt; path[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//path记录路径</span></span><br><span class="line">        path[len++] = T-&gt;data;</span><br><span class="line">        Path0(T-&gt;lchild, path, len);</span><br><span class="line">        Path0(T-&gt;rchild, path, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="270-基于二叉链表的二叉树统计度为-0-1-2-结点个数"><a href="#270-基于二叉链表的二叉树统计度为-0-1-2-结点个数" class="headerlink" title="(270) 基于二叉链表的二叉树统计度为 0 1 2 结点个数"></a>(270) 基于二叉链表的二叉树统计度为 0 1 2 结点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制四种情况的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D0</span><span class="params">(BinTree T)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span>) <span class="keyword">return</span> D0(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> D0(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> D0(T-&gt;lchild) + D0(T-&gt;rchild);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D1</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span> + D1(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;rchild == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span> + D1(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> D1(T-&gt;lchild) + D1(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D2</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span>) <span class="keyword">return</span> D2(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> D2(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + D2(T-&gt;lchild) + D2(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="272-基于二叉链表的二叉树表达式求值"><a href="#272-基于二叉链表的二叉树表达式求值" class="headerlink" title="(272) 基于二叉链表的二叉树表达式求值"></a>(272) 基于二叉链表的二叉树表达式求值</h2><p>我们通常计算的表达式是中缀 比如 2<em>(2+5) = ？ ，计算机喜欢后缀表达式 225+</em> =  ?  ^ _ ^，首先将输入的中缀表达式转成二叉树表示，然后利用后序遍历递归算法计算表达式值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.bjfuacm.com/structure?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BJFUOJ | Data Structure&lt;/a&gt;&lt;/p&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#主体-二叉树结点定义按给定先序建树以及删除&quot;&gt;主体 二叉树结点定义，按给定先序建树以及删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#263-基于二叉链表的二叉树结构相等的判断&quot;&gt;(263) 基于二叉链表的二叉树结构相等的判断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#264-基于二叉链表的二叉树左右孩子的交换&quot;&gt;(264) 基于二叉链表的二叉树左右孩子的交换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#265269-基于二叉链表的二叉树前中后双序遍历-递归&quot;&gt;(265&amp;amp;269) 基于二叉链表的二叉树前中后双序遍历 （递归）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#266-基于二叉链表的二叉树最大宽度&quot;&gt;(266) 基于二叉链表的二叉树最大宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#267271-基于二叉链表的二叉树最长路径--高度&quot;&gt;(267&amp;amp;271) 基于二叉链表的二叉树最长路径  高度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#268-基于二叉链表的二叉树叶子结点到根节点的路径&quot;&gt;(268) 基于二叉链表的二叉树叶子结点到根节点的路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#270-基于二叉链表的二叉树统计度为-0-1-2-结点个数&quot;&gt;(270) 基于二叉链表的二叉树统计度为 0 1 2 结点个数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#272-基于二叉链表的二叉树表达式求值&quot;&gt;(272) 基于二叉链表的二叉树表达式求值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;

&lt;p&gt;复习了树的相关知识，模拟建树，绝知此事要躬行！很多方法要求递归实现，在写递归时，要注意边界条件，递归的前进段、返回段。在脑中模拟出递归的流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="BJFUOJ" scheme="http://yoursite.com/categories/BJFUOJ/"/>
    
    
      <category term="ds" scheme="http://yoursite.com/tags/ds/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BJFUOJ-(214-223)-LinkList</title>
    <link href="http://yoursite.com/2020/02/11/BJFUOJ-(214-223)-LinkList/"/>
    <id>http://yoursite.com/2020/02/11/BJFUOJ-(214-223)-LinkList/</id>
    <published>2020-02-10T16:27:40.000Z</published>
    <updated>2020-02-17T14:16:20.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.bjfuacm.com/structure?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&page=1" target="_blank" rel="noopener">BJFUOJ | Data Structure</a>  </p><!-- TOC --><ul><li><a href="#主体">主体</a></li><li><a href="#214-基于链式存储结构的图书信息表的创建和输出">(214) 基于链式存储结构的图书信息表的创建和输出</a></li><li><a href="#215-基于链式存储结构的图书信息表的排序">(215) 基于链式存储结构的图书信息表的排序</a></li><li><a href="#216-基于链式存储结构的图书信息表的修改">(216) 基于链式存储结构的图书信息表的修改</a></li><li><a href="#217-基于链式存储结构的图书信息表的逆序存储">(217) 基于链式存储结构的图书信息表的逆序存储</a></li><li><a href="#218-基于链式存储结构的图书信息表的最贵图书查找">(218) 基于链式存储结构的图书信息表的最贵图书查找</a></li><li><a href="#219-基于链式存储结构的图书信息表的最爱图书查找">(219) 基于链式存储结构的图书信息表的最爱图书查找</a></li><li><a href="#220-基于链式存储结构的图书信息表的最佳位置图书查找">(220) 基于链式存储结构的图书信息表的最佳位置图书查找</a></li><li><a href="#221-基于链式存储结构的图书信息表的新图书入库">(221) 基于链式存储结构的图书信息表的新图书入库</a></li><li><a href="#222-基于链式存储结构的图书信息表的旧图书出库">(222) 基于链式存储结构的图书信息表的旧图书出库</a></li><li><a href="#223-基于链式存储结构的图书信息表的去重">(223) 基于链式存储结构的图书信息表的去重</a></li></ul><!-- /TOC --><p>复习了链表的相关知识，创建链表以及链表的基本操作的实现。</p><a id="more"></a><hr><h2 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图书结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    book data;</span><br><span class="line">    LNode* next;</span><br><span class="line">&#125;*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">Create1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">LinkList <span class="title">Create2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortLink</span><span class="params">(LinkList t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevLink</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMax</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintFav</span><span class="params">(LinkList p, <span class="built_in">string</span> t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addbook</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delbook</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rembook</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bestposition</span><span class="params">(LinkList p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="comment">//图书数量</span></span><br><span class="line"><span class="keyword">double</span> avg=<span class="number">0</span>;<span class="comment">//平均值</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//指定数量</span></span><br><span class="line"><span class="keyword">double</span> maxbook = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> maxbooknum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用函数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">  </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="214-基于链式存储结构的图书信息表的创建和输出"><a href="#214-基于链式存储结构的图书信息表的创建和输出" class="headerlink" title="(214) 基于链式存储结构的图书信息表的创建和输出"></a>(214) 基于链式存储结构的图书信息表的创建和输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不给数量 建表并输出图书数量</span></span><br><span class="line"><span class="function">LinkList <span class="title">Create1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList head = <span class="keyword">new</span> LNode;</span><br><span class="line">    LinkList p = head;</span><br><span class="line">    book t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t.num &gt;&gt; t.name &gt;&gt; t.price;</span><br><span class="line">    <span class="keyword">for</span>(; !(t.num == <span class="string">"0"</span> &amp;&amp; t.name == <span class="string">"0"</span> &amp;&amp; t.price == <span class="number">0</span>); cnt++) &#123;</span><br><span class="line">        LinkList temp = <span class="keyword">new</span> LNode;</span><br><span class="line">        temp-&gt;data = t;</span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        p = temp;</span><br><span class="line">        avg += t.price;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t.num &gt;&gt; t.name &gt;&gt; t.price;</span><br><span class="line">    &#125;</span><br><span class="line">    avg /= cnt;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>, p-&gt;data.num.c_str(), p-&gt;data.name.c_str(), p-&gt;data.price);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="215-基于链式存储结构的图书信息表的排序"><a href="#215-基于链式存储结构的图书信息表的排序" class="headerlink" title="(215) 基于链式存储结构的图书信息表的排序"></a>(215) 基于链式存储结构的图书信息表的排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortLink</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        LinkList t = p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;data.price &lt; t-&gt;next-&gt;data.price) </span><br><span class="line">                swap(t-&gt;data, t-&gt;next-&gt;data);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="216-基于链式存储结构的图书信息表的修改"><a href="#216-基于链式存储结构的图书信息表的修改" class="headerlink" title="(216) 基于链式存储结构的图书信息表的修改"></a>(216) 基于链式存储结构的图书信息表的修改</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, avg);</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        p-&gt;data.price *= p-&gt;data.price &lt; avg ? <span class="number">1.2</span> : <span class="number">1.1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>, p-&gt;data.num.c_str(), p-&gt;data.name.c_str(), p-&gt;data.price);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="217-基于链式存储结构的图书信息表的逆序存储"><a href="#217-基于链式存储结构的图书信息表的逆序存储" class="headerlink" title="(217) 基于链式存储结构的图书信息表的逆序存储"></a>(217) 基于链式存储结构的图书信息表的逆序存储</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给数量 建表</span></span><br><span class="line"><span class="function">LinkList <span class="title">Create2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList head = <span class="keyword">new</span> LNode;</span><br><span class="line">    LinkList p = head;</span><br><span class="line">    book t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t.num &gt;&gt; t.name &gt;&gt; t.price;</span><br><span class="line">        LinkList temp = <span class="keyword">new</span> LNode;</span><br><span class="line">        temp-&gt;data = t;</span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        p = temp; </span><br><span class="line">        <span class="keyword">if</span>(t.price &gt; maxbook) &#123;</span><br><span class="line">            maxbooknum = <span class="number">1</span>;</span><br><span class="line">            maxbook = t.price;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.price == maxbook)&#123;</span><br><span class="line">            maxbooknum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//逆序存储  head -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; ....</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevLink</span><span class="params">(LinkList p)</span> </span>&#123; </span><br><span class="line">    LinkList cur = p-&gt;next;</span><br><span class="line">    LinkList prev = <span class="literal">NULL</span>;</span><br><span class="line">    LinkList next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = prev;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="218-基于链式存储结构的图书信息表的最贵图书查找"><a href="#218-基于链式存储结构的图书信息表的最贵图书查找" class="headerlink" title="(218) 基于链式存储结构的图书信息表的最贵图书查找"></a>(218) 基于链式存储结构的图书信息表的最贵图书查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出最贵图书</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMax</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxbooknum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.price == maxbook)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>, p-&gt;data.num.c_str(), p-&gt;data.name.c_str(), p-&gt;data.price);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="219-基于链式存储结构的图书信息表的最爱图书查找"><a href="#219-基于链式存储结构的图书信息表的最爱图书查找" class="headerlink" title="(219) 基于链式存储结构的图书信息表的最爱图书查找"></a>(219) 基于链式存储结构的图书信息表的最爱图书查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出最爱图书</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintFav</span><span class="params">(LinkList p, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LinkList r1 = p-&gt;next;</span><br><span class="line">    LinkList r2 = p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(r1) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r1-&gt;data.name == t) cnt++;</span><br><span class="line">        r1 = r1-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>)  <span class="built_in">printf</span>(<span class="string">"Sorry, there is no your favourite!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(r2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r2-&gt;data.name == t) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>, r2-&gt;data.num.c_str(), r2-&gt;data.name.c_str(), r2-&gt;data.price);</span><br><span class="line">        r2 = r2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="220-基于链式存储结构的图书信息表的最佳位置图书查找"><a href="#220-基于链式存储结构的图书信息表的最佳位置图书查找" class="headerlink" title="(220) 基于链式存储结构的图书信息表的最佳位置图书查找"></a>(220) 基于链式存储结构的图书信息表的最佳位置图书查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最佳位置图书查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bestposition</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    LinkList r = p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        LinkList temp = r;</span><br><span class="line">        <span class="keyword">while</span>(temp) &#123;</span><br><span class="line">            t--;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>, temp-&gt;data.num.c_str(), temp-&gt;data.name.c_str(), temp-&gt;data.price);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">"Sorry,the book on the best position doesn't exist!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="221-基于链式存储结构的图书信息表的新图书入库"><a href="#221-基于链式存储结构的图书信息表的新图书入库" class="headerlink" title="(221) 基于链式存储结构的图书信息表的新图书入库"></a>(221) 基于链式存储结构的图书信息表的新图书入库</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addbook</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    LinkList r = p-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m; </span><br><span class="line">    book t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t.num &gt;&gt; t.name &gt;&gt; t.price;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n) <span class="built_in">printf</span>(<span class="string">"Sorry, the position to be inserted is invalid!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; m<span class="number">-1</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList temp = <span class="keyword">new</span> LNode;</span><br><span class="line">        temp-&gt;data = t;</span><br><span class="line">        temp-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp; </span><br><span class="line">        Print(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="222-基于链式存储结构的图书信息表的旧图书出库"><a href="#222-基于链式存储结构的图书信息表的旧图书出库" class="headerlink" title="(222) 基于链式存储结构的图书信息表的旧图书出库"></a>(222) 基于链式存储结构的图书信息表的旧图书出库</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delbook</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    LinkList r = p-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> m; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n) <span class="built_in">printf</span>(<span class="string">"Sorry,the position to be deleted is invalid!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; m<span class="number">-1</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(temp);</span><br><span class="line">        Print(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="223-基于链式存储结构的图书信息表的去重"><a href="#223-基于链式存储结构的图书信息表的去重" class="headerlink" title="(223) 基于链式存储结构的图书信息表的去重"></a>(223) 基于链式存储结构的图书信息表的去重</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rembook</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">    LinkList r = p-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator result = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p-&gt;next-&gt;data.num);</span><br><span class="line">        <span class="keyword">if</span>(result == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            v.push_back(p-&gt;next-&gt;data.num);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LinkList temp = p-&gt;next;</span><br><span class="line">            p-&gt;next = temp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Print(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.bjfuacm.com/structure?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BJFUOJ | Data Structure&lt;/a&gt;  &lt;/p&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#主体&quot;&gt;主体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#214-基于链式存储结构的图书信息表的创建和输出&quot;&gt;(214) 基于链式存储结构的图书信息表的创建和输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#215-基于链式存储结构的图书信息表的排序&quot;&gt;(215) 基于链式存储结构的图书信息表的排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#216-基于链式存储结构的图书信息表的修改&quot;&gt;(216) 基于链式存储结构的图书信息表的修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#217-基于链式存储结构的图书信息表的逆序存储&quot;&gt;(217) 基于链式存储结构的图书信息表的逆序存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#218-基于链式存储结构的图书信息表的最贵图书查找&quot;&gt;(218) 基于链式存储结构的图书信息表的最贵图书查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#219-基于链式存储结构的图书信息表的最爱图书查找&quot;&gt;(219) 基于链式存储结构的图书信息表的最爱图书查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#220-基于链式存储结构的图书信息表的最佳位置图书查找&quot;&gt;(220) 基于链式存储结构的图书信息表的最佳位置图书查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#221-基于链式存储结构的图书信息表的新图书入库&quot;&gt;(221) 基于链式存储结构的图书信息表的新图书入库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#222-基于链式存储结构的图书信息表的旧图书出库&quot;&gt;(222) 基于链式存储结构的图书信息表的旧图书出库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#223-基于链式存储结构的图书信息表的去重&quot;&gt;(223) 基于链式存储结构的图书信息表的去重&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;

&lt;p&gt;复习了链表的相关知识，创建链表以及链表的基本操作的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="BJFUOJ" scheme="http://yoursite.com/categories/BJFUOJ/"/>
    
    
      <category term="ds" scheme="http://yoursite.com/tags/ds/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>BJFUOJ-(204-213)-ArrayList</title>
    <link href="http://yoursite.com/2020/02/10/BJFUOJ-(204-213)-ArrayList/"/>
    <id>http://yoursite.com/2020/02/10/BJFUOJ-(204-213)-ArrayList/</id>
    <published>2020-02-10T12:11:49.000Z</published>
    <updated>2020-02-17T14:16:15.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.bjfuacm.com/structure?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&page=1" target="_blank" rel="noopener">BJFUOJ | Data Structure</a></p><!-- TOC --><ul><li><a href="#主体">主体</a></li><li><a href="#204-基于顺序存储结构的图书信息表的创建和输出">(204) 基于顺序存储结构的图书信息表的创建和输出</a></li><li><a href="#205-基于顺序存储结构的图书信息表的排序">(205) 基于顺序存储结构的图书信息表的排序</a></li><li><a href="#206-基于顺序存储结构的图书信息表的修改">(206) 基于顺序存储结构的图书信息表的修改</a></li><li><a href="#207-基于顺序存储结构的图书信息表的逆序存储">(207) 基于顺序存储结构的图书信息表的逆序存储</a></li><li><a href="#208-基于顺序存储结构的图书信息表的最贵图书的查找">(208) 基于顺序存储结构的图书信息表的最贵图书的查找</a></li><li><a href="#209-基于顺序存储结构的图书信息表的最爱图书的查找">(209) 基于顺序存储结构的图书信息表的最爱图书的查找</a></li><li><a href="#210-基于顺序存储结构的图书信息表的最佳位置图书的查找">(210) 基于顺序存储结构的图书信息表的最佳位置图书的查找</a></li><li><a href="#211-基于顺序存储结构的图书信息表的新图书的入库">(211) 基于顺序存储结构的图书信息表的新图书的入库</a></li><li><a href="#212-基于顺序存储结构的图书信息表的旧图书的出库">(212) 基于顺序存储结构的图书信息表的旧图书的出库</a></li><li><a href="#213-基于顺序存储结构的图书信息表的图书去重">(213) 基于顺序存储结构的图书信息表的图书去重</a></li></ul><!-- /TOC --><p>线性表-数组的基本操作，比较简单。</p><a id="more"></a><h2 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;AList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;  <span class="comment">//个数</span></span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">//总和，计算平均数用</span></span><br><span class="line"><span class="keyword">double</span> maxbook = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> maxbooknum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(book x, book y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpBook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FavBook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BesBook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addbook</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delbook</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rembook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   调用函数</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="204-基于顺序存储结构的图书信息表的创建和输出"><a href="#204-基于顺序存储结构的图书信息表的创建和输出" class="headerlink" title="(204) 基于顺序存储结构的图书信息表的创建和输出"></a>(204) 基于顺序存储结构的图书信息表的创建和输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create1</span><span class="params">()</span> </span>&#123;    <span class="comment">//不给数量创建</span></span><br><span class="line">    book temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; temp.num &gt;&gt; temp.name &gt;&gt; temp.price) &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.num == <span class="string">"0"</span> &amp;&amp; temp.name == <span class="string">"0"</span> &amp;&amp; temp.price == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        AList[n++] = temp;</span><br><span class="line">        sum += temp.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>,AList[i].num.c_str(), AList[i].name.c_str(), AList[i].price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="205-基于顺序存储结构的图书信息表的排序"><a href="#205-基于顺序存储结构的图书信息表的排序" class="headerlink" title="(205) 基于顺序存储结构的图书信息表的排序"></a>(205) 基于顺序存储结构的图书信息表的排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(book x, book y)</span> </span>&#123;  <span class="comment">//排序 价格降序</span></span><br><span class="line">    <span class="keyword">return</span> x.price &gt; y.price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="206-基于顺序存储结构的图书信息表的修改"><a href="#206-基于顺序存储结构的图书信息表的修改" class="headerlink" title="(206) 基于顺序存储结构的图书信息表的修改"></a>(206) 基于顺序存储结构的图书信息表的修改</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">()</span> </span>&#123;   <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, sum / n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        AList[i].price *= (AList[i].price &lt; (sum / n) ? <span class="number">1.2</span> : <span class="number">1.1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>,AList[i].num.c_str(), AList[i].name.c_str(), AList[i].price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="207-基于顺序存储结构的图书信息表的逆序存储"><a href="#207-基于顺序存储结构的图书信息表的逆序存储" class="headerlink" title="(207) 基于顺序存储结构的图书信息表的逆序存储"></a>(207) 基于顺序存储结构的图书信息表的逆序存储</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevCreate</span><span class="params">()</span> </span>&#123;  <span class="comment">//逆序存储</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; AList[i].num &gt;&gt; AList[i].name &gt;&gt; AList[i].price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="208-基于顺序存储结构的图书信息表的最贵图书的查找"><a href="#208-基于顺序存储结构的图书信息表的最贵图书的查找" class="headerlink" title="(208) 基于顺序存储结构的图书信息表的最贵图书的查找"></a>(208) 基于顺序存储结构的图书信息表的最贵图书的查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create2</span><span class="params">()</span> </span>&#123;    <span class="comment">//给数量创建</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; AList[i].num &gt;&gt; AList[i].name &gt;&gt; AList[i].price;</span><br><span class="line">        <span class="keyword">if</span>(AList[i].price &gt; maxbook) &#123;</span><br><span class="line">            maxbook = AList[i].price;</span><br><span class="line">            maxbooknum = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(AList[i].price == maxbook) maxbooknum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最贵图书查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxbooknum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(AList[i].price == maxbook) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>,AList[i].num.c_str(), AList[i].name.c_str(), AList[i].price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="209-基于顺序存储结构的图书信息表的最爱图书的查找"><a href="#209-基于顺序存储结构的图书信息表的最爱图书的查找" class="headerlink" title="(209) 基于顺序存储结构的图书信息表的最爱图书的查找"></a>(209) 基于顺序存储结构的图书信息表的最爱图书的查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FavBook</span><span class="params">()</span> </span>&#123;    <span class="comment">//最爱图书查找</span></span><br><span class="line">    <span class="keyword">int</span> m,a[MAXSIZE];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(AList[i].name == t) &#123; </span><br><span class="line">                a[cnt++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Sorry，there is no your favourite!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>,AList[a[i]].num.c_str(), AList[a[i]].name.c_str(), AList[a[i]].price);</span><br><span class="line">            &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="210-基于顺序存储结构的图书信息表的最佳位置图书的查找"><a href="#210-基于顺序存储结构的图书信息表的最佳位置图书的查找" class="headerlink" title="(210) 基于顺序存储结构的图书信息表的最佳位置图书的查找"></a>(210) 基于顺序存储结构的图书信息表的最佳位置图书的查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BesBook</span><span class="params">()</span> </span>&#123;    <span class="comment">//最佳位置图书查找</span></span><br><span class="line">    <span class="keyword">int</span> m,t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t &lt;= n &amp;&amp; t &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%s %s %.2lf\n"</span>,AList[t<span class="number">-1</span>].num.c_str(), AList[t<span class="number">-1</span>].name.c_str(), AList[t<span class="number">-1</span>].price);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Sorry，the book on the best position doesn't exist!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="211-基于顺序存储结构的图书信息表的新图书的入库"><a href="#211-基于顺序存储结构的图书信息表的新图书的入库" class="headerlink" title="(211) 基于顺序存储结构的图书信息表的新图书的入库"></a>(211) 基于顺序存储结构的图书信息表的新图书的入库</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addbook</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;   <span class="comment">//新书入库</span></span><br><span class="line">    book t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t.num &gt;&gt; t.name &gt;&gt; t.price;   </span><br><span class="line">    <span class="keyword">if</span>(k &gt; n || k &lt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Sorry，the position to be inserted is invalid!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &lt; n; i++)</span><br><span class="line">            swap(t, AList[i]);</span><br><span class="line">        AList[n] = t;</span><br><span class="line">        n++;</span><br><span class="line">        Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="212-基于顺序存储结构的图书信息表的旧图书的出库"><a href="#212-基于顺序存储结构的图书信息表的旧图书的出库" class="headerlink" title="(212) 基于顺序存储结构的图书信息表的旧图书的出库"></a>(212) 基于顺序存储结构的图书信息表的旧图书的出库</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delbook</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;   <span class="comment">//旧书出库</span></span><br><span class="line">    <span class="keyword">if</span>(k &gt; n || k &lt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Sorry，the position to be deleted is invalid!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; n + <span class="number">1</span>) &#123;</span><br><span class="line">            AList[k<span class="number">-1</span>] = AList[k];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="comment">//Print();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="213-基于顺序存储结构的图书信息表的图书去重"><a href="#213-基于顺序存储结构的图书信息表的图书去重" class="headerlink" title="(213) 基于顺序存储结构的图书信息表的图书去重"></a>(213) 基于顺序存储结构的图书信息表的图书去重</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rembook</span><span class="params">()</span> </span>&#123;    <span class="comment">//去重</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator result = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), AList[i].num);</span><br><span class="line">        <span class="keyword">if</span>(result == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            v.push_back(AList[i].num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Delbook(i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.bjfuacm.com/structure?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BJFUOJ | Data Structure&lt;/a&gt;&lt;/p&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#主体&quot;&gt;主体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#204-基于顺序存储结构的图书信息表的创建和输出&quot;&gt;(204) 基于顺序存储结构的图书信息表的创建和输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#205-基于顺序存储结构的图书信息表的排序&quot;&gt;(205) 基于顺序存储结构的图书信息表的排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#206-基于顺序存储结构的图书信息表的修改&quot;&gt;(206) 基于顺序存储结构的图书信息表的修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#207-基于顺序存储结构的图书信息表的逆序存储&quot;&gt;(207) 基于顺序存储结构的图书信息表的逆序存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#208-基于顺序存储结构的图书信息表的最贵图书的查找&quot;&gt;(208) 基于顺序存储结构的图书信息表的最贵图书的查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#209-基于顺序存储结构的图书信息表的最爱图书的查找&quot;&gt;(209) 基于顺序存储结构的图书信息表的最爱图书的查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#210-基于顺序存储结构的图书信息表的最佳位置图书的查找&quot;&gt;(210) 基于顺序存储结构的图书信息表的最佳位置图书的查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#211-基于顺序存储结构的图书信息表的新图书的入库&quot;&gt;(211) 基于顺序存储结构的图书信息表的新图书的入库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#212-基于顺序存储结构的图书信息表的旧图书的出库&quot;&gt;(212) 基于顺序存储结构的图书信息表的旧图书的出库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#213-基于顺序存储结构的图书信息表的图书去重&quot;&gt;(213) 基于顺序存储结构的图书信息表的图书去重&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;

&lt;p&gt;线性表-数组的基本操作，比较简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="BJFUOJ" scheme="http://yoursite.com/categories/BJFUOJ/"/>
    
    
      <category term="ds" scheme="http://yoursite.com/tags/ds/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>PAT-19年秋乙级真题-擅长C</title>
    <link href="http://yoursite.com/2020/02/10/PAT-19%E5%B9%B4%E5%86%AC%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98-%E6%93%85%E9%95%BFC/"/>
    <id>http://yoursite.com/2020/02/10/PAT-19%E5%B9%B4%E5%86%AC%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98-%E6%93%85%E9%95%BFC/</id>
    <published>2020-02-10T11:57:39.000Z</published>
    <updated>2020-02-10T20:49:06.946Z</updated>
    
    <content type="html"><![CDATA[<p>那天在机房没做出来，太着急了,回来后静下心做了一遍，思路清晰地去写还是比较容易做出来的。  </p><hr><p>&emsp;&emsp;7-4 擅长C (20分)  </p><p><img src="/2020/02/10/PAT-19%E5%B9%B4%E5%86%AC%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98-%E6%93%85%E9%95%BFC/1.jpg" alt="0"></p><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入首先给出 26 个英文大写字母 A-Z，每个字母用一个 7×5 的、由 C 和 . 组成的矩阵构成。最后在一行中给出一个句子，以回车结束。句子是由若干个单词（每个包含不超过 10 个连续的大写英文字母）组成的，单词间以任何非大写英文字母分隔。</p><p>题目保证至少给出一个单词。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每个单词，将其每个字母用矩阵形式在一行中输出，字母间有一列空格分隔。单词的首尾不得有多余空格。<br>相邻的两个单词间必须有一空行分隔。输出的首尾不得有多余空行。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; s; <span class="comment">//用vector放26个字母  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pp</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[a][i][j]; <span class="comment">//s[a] 第a个字母 s[a][i] </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++)&#123;<span class="comment">//每个字母是7行5列</span></span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">v.push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">s.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.length(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>], b=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">word</span>[i] &lt;= <span class="string">'Z'</span> &amp;&amp; <span class="keyword">word</span>[i] &gt;= <span class="string">'A'</span> &amp;&amp; i&lt;<span class="keyword">word</span>.length())&#123;</span><br><span class="line">a[b++] = <span class="keyword">word</span>[i] - <span class="string">'A'</span>;</span><br><span class="line">i++; cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r1, r2;</span><br><span class="line"><span class="keyword">for</span>(r2 = <span class="number">0</span>; r2 &lt; <span class="number">7</span>; r2++) &#123;<span class="comment">//7行 </span></span><br><span class="line"><span class="keyword">for</span>(r1 = <span class="number">0</span>; r1 &lt; cnt; r1++)&#123;<span class="comment">//字母顺序 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[a[r1]][r2];<span class="comment">//输出字母第r2行 </span></span><br><span class="line"><span class="keyword">if</span>(r1 &lt; cnt<span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;<span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="keyword">word</span>.length() - <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/10/PAT-19%E5%B9%B4%E5%86%AC%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98-%E6%93%85%E9%95%BFC/2.JPG" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那天在机房没做出来，太着急了,回来后静下心做了一遍，思路清晰地去写还是比较容易做出来的。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;7-4 擅长C (20分)  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/10/PAT-19%E5%B9%B4%E5%86%AC%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98-%E6%93%85%E9%95%BFC/1.jpg&quot; alt=&quot;0&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT" scheme="http://yoursite.com/categories/PAT/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>网页图片加载失败问题</title>
    <link href="http://yoursite.com/2020/02/10/pictureErr/"/>
    <id>http://yoursite.com/2020/02/10/pictureErr/</id>
    <published>2020-02-10T07:00:13.000Z</published>
    <updated>2020-02-10T17:26:40.986Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%9b%be%e7%89%87%e9%97%ae%e9%a2%98">图片问题</a></li><li><a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95">解决方法</a></li></ul><!-- /TOC --><h2 id="图片问题"><a href="#图片问题" class="headerlink" title="图片问题"></a>图片问题</h2><p>浏览某网页时发现头像等图片都挂掉了，刚开始以为是加载不出来，后来在浏览vscode插件的介绍中发现也不能加载图片。  </p><p>github &emsp;<br><img src="/2020/02/10/pictureErr/1.JPG" alt="0"></p><p>vscode  （忘记截图了^_^）</p><a id="more"></a><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>经过搜索，原因可能是<a href="https://baike.baidu.com/item/DNS%E6%B1%A1%E6%9F%93" target="_blank" rel="noopener">DNS污染</a>，通过修改hosts文件解决了。</p><ul><li>C:\Windows\System32\drivers\etc 目录下 hosts 添加内容</li></ul><p><img src="/2020/02/10/pictureErr/2.JPG" alt="0"></p><p>网址可通过浏览器检查 找到<br>然后根据src<a href="www.ipaddress.com/">查询域名</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%9b%be%e7%89%87%e9%97%ae%e9%a2%98&quot;&gt;图片问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95&quot;&gt;解决方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;图片问题&quot;&gt;&lt;a href=&quot;#图片问题&quot; class=&quot;headerlink&quot; title=&quot;图片问题&quot;&gt;&lt;/a&gt;图片问题&lt;/h2&gt;&lt;p&gt;浏览某网页时发现头像等图片都挂掉了，刚开始以为是加载不出来，后来在浏览vscode插件的介绍中发现也不能加载图片。  &lt;/p&gt;
&lt;p&gt;github &amp;emsp;&lt;br&gt;&lt;img src=&quot;/2020/02/10/pictureErr/1.JPG&quot; alt=&quot;0&quot;&gt;&lt;/p&gt;
&lt;p&gt;vscode  （忘记截图了^_^）&lt;/p&gt;
    
    </summary>
    
    
      <category term="none" scheme="http://yoursite.com/categories/none/"/>
    
    
  </entry>
  
  <entry>
    <title>MarkDown</title>
    <link href="http://yoursite.com/2020/02/10/MarkDown/"/>
    <id>http://yoursite.com/2020/02/10/MarkDown/</id>
    <published>2020-02-09T21:48:48.000Z</published>
    <updated>2020-02-21T19:48:48.558Z</updated>
    
    <content type="html"><![CDATA[<p>挖个坑……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;挖个坑……&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub = Blog!</title>
    <link href="http://yoursite.com/2020/02/09/hexo/"/>
    <id>http://yoursite.com/2020/02/09/hexo/</id>
    <published>2020-02-09T13:44:18.000Z</published>
    <updated>2020-02-17T13:57:13.816Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/02/09/hexo/1.jpg" alt="1"><br>&emsp;&emsp;考研前就想过搭建属于自己的空间，之前一直使用 印象笔记 这类应用记录。而自己购买域名服务器搭建博客需要一定开销^_^，某天刷b站时了解到可以使用github page构建属于自己的小站点。<br>&emsp;&emsp;于是，在一个安静的下午，决定完成它。<br>&emsp;&emsp;使用了Hexo静态博客框架，将生成的静态网页托管在GitHub上。就愉快地走进了Blog的大门！</p><a id="more"></a><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p> <a href="https://gitforwindows.org/" target="_blank" rel="noopener">下载地址</a>  </p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p> <a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a></p><hr><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id><a href="#" class="headerlink" title></a></h3><p>桌面右键选择 Git Bash Here，输入命令</p><pre><code>npm install -g hexo</code></pre><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo:"></a>初始化Hexo:</h3><p>在刚才生成的blog文件夹下 右键Git Bush Here，输入命令</p><pre><code>hexo init</code></pre><p><img src="/2020/02/09/hexo/2.jpg" alt="1"></p><h3 id="本地博客"><a href="#本地博客" class="headerlink" title="本地博客"></a>本地博客</h3><p>输入如下命令:</p><pre><code>hexo s</code></pre><p>在浏览器输入     localhost:4000  就可以访问啦</p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><pre><code>hexo n &quot;我的第一篇blog&quot;</code></pre><hr><h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>刚才只是在本地生成了静态博客，接下来要发布网站，也就是将Hexo部署到Github上。</p><h3 id="new一个仓库"><a href="#new一个仓库" class="headerlink" title="new一个仓库"></a>new一个仓库</h3><p><img src="/2020/02/09/hexo/3.jpg" alt="1"></p><h3 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a>安装git部署插件</h3><p>blog下输入命令</p><pre><code>npm install --save hexo-deployer-git</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>编辑blog文件夹里的 _config.yml 文件:<br>添加 repo: 仓库地址<br>&emsp;&emsp; branch: master<br><img src="/2020/02/09/hexo/4.jpg" alt="1"><br>还可以顺便设置一下名字什么的<br><img src="/2020/02/09/hexo/2.jpg" alt="1"></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>hexo d</code></pre><p>这时第一次会要求输入github账号密码，部署后就可以通过 alvin103.github.io 访问博客了！写了新文章可以先在本地调试好之后发布</p><p>以后发布文章输入这两个命令就ok</p><pre><code>hexo cleanhexo d -g </code></pre><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>更换了Hexo主题next ^_^  后面有时间想自己做一个Theme  </p><p>在写文章时也遇到一些问题，比如添加图片、编码格式等等都可以通过搜索获得帮助。  </p><p>写到这里，就是总结一些经验.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/02/09/hexo/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;考研前就想过搭建属于自己的空间，之前一直使用 印象笔记 这类应用记录。而自己购买域名服务器搭建博客需要一定开销^_^，某天刷b站时了解到可以使用github page构建属于自己的小站点。&lt;br&gt;&amp;emsp;&amp;emsp;于是，在一个安静的下午，决定完成它。&lt;br&gt;&amp;emsp;&amp;emsp;使用了Hexo静态博客框架，将生成的静态网页托管在GitHub上。就愉快地走进了Blog的大门！&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/02/09/Hello%20World/"/>
    <id>http://yoursite.com/2020/02/09/Hello%20World/</id>
    <published>2020-02-09T11:44:18.000Z</published>
    <updated>2020-02-10T17:18:47.406Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#2020">2020</a></li><li><a href="#end">END</a></li></ul><!-- /TOC --><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>Zzh 的 Blog 就这样开始了</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#2020&quot;&gt;2020&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#end&quot;&gt;END&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;

&lt;h2 id=&quot;2020&quot;&gt;&lt;a href=&quot;#2020&quot; clas
      
    
    </summary>
    
    
      <category term="none" scheme="http://yoursite.com/categories/none/"/>
    
    
  </entry>
  
</feed>
